{"id":"Rusticulum-0rc","title":"Encapsulate PacketRouter fields (reticulum-transport)","description":"type: task","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-12T23:01:53.154157869-05:00","updated_at":"2026-02-13T15:12:55.085305135Z","closed_at":"2026-02-13T15:12:55.085307206Z"}
{"id":"Rusticulum-1ir","title":"Replace .expect() panics with proper error handling (reticulum-node, reticulum-interfaces)","description":"type: bug","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-02-12T23:01:53.152980975-05:00","updated_at":"2026-02-13T14:37:54.953260114Z","closed_at":"2026-02-13T14:37:54.953260114Z","close_reason":"Closed"}
{"id":"Rusticulum-3a5","title":"Integration Testing and Interop","description":"End-to-end integration testing with the Python reference implementation. Includes: Docker compose setup with Python reference node, announce exchange (bidirectional), link establishment (bidirectional), resource transfer (bidirectional), channel/buffer protocol testing, multi-hop routing through mixed Rust/Python transport nodes. This validates full protocol interoperability.","status":"open","priority":1,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:15:01.162928977Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:15:01.162928977Z","dependencies":[{"issue_id":"Rusticulum-3a5","depends_on_id":"Rusticulum-nrn","type":"blocks","created_at":"2026-02-08T03:15:08.695214477Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.1","title":"Set up Docker environment with Python reference node","description":"Create a Docker Compose configuration that runs both the Rust Reticulum implementation and the Python reference implementation (v1.1.3) as peer nodes:\n\nDocker setup:\n- Dockerfile for Rust node (build from workspace, run reticulum-node binary)\n- Dockerfile or image for Python Reticulum reference (pip install rns==1.1.3)\n- docker-compose.yml with both services on a shared network\n- Shared TCP interface configuration so nodes can communicate\n- Volume mounts for identity persistence and logs\n- Health checks for both nodes\n\nConfiguration:\n- Python node config: TCP interface listening on a known port\n- Rust node config: TCP interface connecting to Python node\n- Both nodes with transport enabled for multi-hop testing\n- Separate network segments for multi-hop scenarios (requires 3+ nodes)\n\nTest runner:\n- Script to start the environment, wait for nodes to be ready, run integration tests, collect results\n- Support for running individual test scenarios\n- Log collection from both nodes for debugging\n\nAdd tracing integration: Rust node logs should be structured JSON for easy parsing in test assertions.\n\nAcceptance: docker-compose up starts both nodes, they can reach each other via TCP, logs are accessible.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:39:45.809419943Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T17:18:34.604572836Z","closed_at":"2026-02-13T17:18:34.604572836Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-3a5.1","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:39:45.810161043Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.2","title":"Test bidirectional announce exchange","description":"Integration test: verify announce packets are correctly exchanged between Rust and Python nodes.\n\nTest scenarios:\n1. Rust announces, Python validates:\n   - Rust node creates a destination with known app_name/aspects\n   - Rust node sends announce\n   - Python node receives and validates the announce (signature, destination hash)\n   - Verify Python node has the Rust destination in its known destinations\n\n2. Python announces, Rust validates:\n   - Python node creates a destination\n   - Python node sends announce  \n   - Rust node receives and validates the announce\n   - Verify Rust node has the Python destination in its path table\n\n3. Announce with app_data:\n   - Both directions with optional app_data payload\n   - Verify app_data is preserved\n\n4. Announce with ratchet:\n   - Both directions with ratchet key\n   - Verify ratchet is correctly propagated\n\nValidation:\n- Destination hashes match between implementations\n- Signatures verify correctly cross-implementation\n- Path table entries are created with correct TTLs\n- Announce propagation follows rate limiting rules\n\nAcceptance: All announce scenarios pass bidirectionally between Rust and Python nodes.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:39:50.942587987Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T17:35:10.362435589Z","closed_at":"2026-02-13T17:35:10.362435589Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-3a5.2","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:39:50.943185042Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.2","depends_on_id":"Rusticulum-3a5.1","type":"blocks","created_at":"2026-02-08T03:40:40.138226634Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.3","title":"Test bidirectional link establishment","description":"Integration test: verify link handshake works between Rust and Python implementations.\n\nTest scenarios:\n1. Rust initiator, Python responder:\n   - Rust node initiates link to Python destination\n   - 3-packet handshake completes (LINKREQUEST -\u003e LRPROOF -\u003e LRRTT)\n   - Both sides derive same key (verified by successful encrypt/decrypt)\n   - Link enters Active state on both sides\n\n2. Python initiator, Rust responder:\n   - Python node initiates link to Rust destination\n   - Same handshake verification\n   - Link Active on both sides\n\n3. Link with MTU signalling:\n   - Negotiate non-default MTU during handshake\n   - Verify both sides agree on effective MDU\n\n4. Link keepalive:\n   - Established link stays alive with keepalive packets\n   - Verify keepalive interval is computed consistently\n\n5. Link close:\n   - Graceful link close from both sides\n   - Verify both sides transition to Closed state\n\n6. Data over link:\n   - Send data packets over established link\n   - Verify encryption/decryption works cross-implementation\n   - Send maximum-size data (MDU)\n   - Send minimal data (1 byte)\n\nAcceptance: Links can be established and used for encrypted communication in both directions.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:39:59.940958252Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T18:17:01.407735902Z","closed_at":"2026-02-13T18:17:01.407735902Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-3a5.3","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:39:59.94139723Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.3","depends_on_id":"Rusticulum-3a5.1","type":"blocks","created_at":"2026-02-08T03:40:45.590014648Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.3","depends_on_id":"Rusticulum-3a5.2","type":"blocks","created_at":"2026-02-08T03:40:45.612229936Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.4","title":"Test bidirectional resource transfers","description":"Integration test: verify resource transfer protocol works between implementations.\n\nTest scenarios:\n1. Rust sends resource to Python:\n   - Create resource from known data\n   - Advertise resource over established link\n   - Transfer all parts\n   - Python verifies resource proof\n   - Python has correct reassembled data\n\n2. Python sends resource to Rust:\n   - Same flow in reverse direction\n   - Rust validates and reassembles correctly\n\n3. Small resource (single part):\n   - Data fits in one part\n   - Verify advertisement, transfer, proof\n\n4. Large resource (multiple parts):\n   - Data requires multiple parts and window management\n   - Verify all parts transfer correctly\n   - Verify window adaptation occurs\n\n5. Resource with compression:\n   - Data that benefits from compression\n   - Verify compressed transfer works\n\n6. Segmented resource:\n   - Resource exceeding MAX_EFFICIENT_SIZE (1,048,575 bytes)\n   - Verify segmentation and reassembly\n\n7. Failed transfer recovery:\n   - Simulate packet loss (drop random parts)\n   - Verify retransmission and eventual success\n\nAcceptance: Resources transfer correctly in both directions for all size classes.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:40:04.424228354Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T19:46:02.204816158Z","closed_at":"2026-02-13T19:46:02.204816158Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-3a5.4","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:40:04.424786197Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.4","depends_on_id":"Rusticulum-3a5.3","type":"blocks","created_at":"2026-02-08T03:40:48.54454401Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.5","title":"Test channel and buffer protocols","description":"Integration test: verify channel and buffer protocols work between implementations.\n\nTest scenarios:\n1. Channel messages:\n   - Send channel messages from Rust to Python and vice versa\n   - Verify envelope packing/unpacking is compatible\n   - Verify sequence numbers are tracked correctly\n   - Test window flow control\n\n2. Buffer stream:\n   - Stream data from Rust to Python using buffer protocol\n   - Stream data from Python to Rust\n   - Verify stream header encoding is compatible\n   - Verify EOF detection works\n   - Test with compressed and uncompressed data\n\n3. Request/Response:\n   - Rust sends request, Python responds\n   - Python sends request, Rust responds\n   - Verify msgpack encoding is compatible\n   - Test with various payload sizes\n\n4. Channel with many messages:\n   - Send enough messages to trigger sequence wrapping (65536+)\n   - Verify wrapping is handled correctly on both sides\n\n5. Buffer with large data:\n   - Stream data larger than a single chunk\n   - Verify chunking and reassembly\n\nAcceptance: All channel/buffer/request-response scenarios pass bidirectionally.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:40:09.208374617Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T20:57:09.181877391Z","closed_at":"2026-02-13T20:57:09.181877391Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-3a5.5","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:40:09.208973792Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.5","depends_on_id":"Rusticulum-3a5.3","type":"blocks","created_at":"2026-02-08T03:40:52.815901389Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.6","title":"Test multi-hop routing through mixed nodes","description":"Integration test: verify multi-hop routing works through mixed Rust/Python transport nodes.\n\nTest scenarios:\n1. Three-node chain: Rust -\u003e Python -\u003e Rust\n   - Source Rust node sends to destination Rust node\n   - Python node acts as transport relay\n   - Verify packet is forwarded correctly\n   - Verify transport headers are correctly inserted/removed\n\n2. Three-node chain: Python -\u003e Rust -\u003e Python\n   - Same but Rust acts as relay\n   - Verify Rust correctly forwards packets\n\n3. Announce propagation through relay:\n   - Announce originates at one end\n   - Propagates through relay\n   - Reaches far end with incremented hop count\n\n4. Path discovery through relay:\n   - Destination is only reachable through relay\n   - Path table correctly records multi-hop path\n   - Data flows through the discovered path\n\n5. Four-node topology:\n   - A -\u003e B -\u003e C -\u003e D with mixed implementations\n   - Verify end-to-end communication\n   - Verify path table entries at each hop\n\n6. Link through relay:\n   - Establish link between non-adjacent nodes\n   - Verify encrypted link works over multiple hops\n\nAcceptance: Multi-hop routing works correctly through any mix of Rust and Python nodes.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:40:14.230787344Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T23:12:20.99894263Z","closed_at":"2026-02-13T23:12:20.99894263Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-3a5.6","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:40:14.231327306Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.6","depends_on_id":"Rusticulum-3a5.1","type":"blocks","created_at":"2026-02-08T03:40:56.802356471Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.6","depends_on_id":"Rusticulum-3a5.2","type":"blocks","created_at":"2026-02-08T03:40:56.823660831Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.6","depends_on_id":"Rusticulum-3a5.3","type":"blocks","created_at":"2026-02-08T03:40:56.845630678Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.7","title":"Comprehensive cross-implementation compatibility test suite","description":"Create a comprehensive test suite that validates full protocol compatibility:\n\n1. Deterministic test suite:\n   - Run all JSON test vectors through both Rust and Python implementations\n   - Verify both produce identical outputs for identical inputs\n   - Compare: hashes, signatures, encrypted outputs, packet encodings, announce payloads\n\n2. Fuzz testing:\n   - Generate random valid packets with proptest\n   - Feed to Python implementation for validation\n   - Feed Python-generated packets to Rust for validation\n   - Verify no crashes or protocol violations\n\n3. Stress testing:\n   - Many concurrent links\n   - Many simultaneous resource transfers\n   - Rapid announce bursts\n   - Connection drops and reconnects\n\n4. Edge case testing:\n   - Maximum size packets (MTU=500)\n   - Minimum size packets\n   - Empty payloads where allowed\n   - Maximum hop count announces\n   - Expired path entries\n   - Duplicate packet handling\n\n5. Protocol version compatibility:\n   - Verify Rust implementation correctly handles all packet types\n   - Verify no unknown context types cause crashes\n   - Graceful handling of malformed packets\n\nCreate a CI-runnable test suite that can be run against any pair of implementations.\n\nAcceptance: Full compatibility test suite passes, documenting any known differences.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:40:20.692829323Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T17:02:26.714422351Z","closed_at":"2026-02-14T17:02:26.714422351Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:40:20.693378895Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.2","type":"blocks","created_at":"2026-02-08T03:41:01.397837484Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.3","type":"blocks","created_at":"2026-02-08T03:41:01.419810632Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.4","type":"blocks","created_at":"2026-02-08T03:41:01.441351992Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.5","type":"blocks","created_at":"2026-02-08T03:41:01.462982996Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.6","type":"blocks","created_at":"2026-02-08T03:41:01.484707513Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.8","title":"Test buffer stream protocol (Rust ↔ Python)","description":"Buffer stream interop was not completed in Rusticulum-3a5.5. The channel and request/response protocols work bidirectionally, but buffer streams (SMT_STREAM_DATA = 0xFF00) were deferred.\n\n**Problem:** Python's Channel API rejects MSGTYPE 0xFF00 as a system-reserved message type — `channel.register_message_type()` raises `ChannelException`. The 0xFF00 message type is handled internally by RNS via `RNS.Buffer`, not through user-facing Channel message registration.\n\n**Correct approach:** Use Python's `RNS.Buffer.create_bidirectional_buffer(link)` API, which internally manages the 0xFF00 stream data messages through the Channel's system message path. On the Rust side, the protocol-layer `StreamDataMessage` (pack/unpack) and `ChannelState` already support 0xFF00 — the missing piece is node-level buffer lifecycle management and the Python test script using the proper Buffer API.\n\n**What exists:**\n- Protocol crate: `buffer/stream_data.rs` — StreamHeader, StreamDataMessage, compress_chunk, write_chunk\n- Protocol crate: `buffer/constants.rs` — SMT_STREAM_DATA=0xFF00, STREAM_DATA_OVERHEAD, MAX_DATA_LEN\n- Channel manager: basic stream data accumulation (handle_stream_data, rx_buffer)\n- Docker test infra: test-channel.sh, docker-compose, configs all in place\n\n**What's needed:**\n1. Python test script: Replace manual StreamMessage class with `RNS.Buffer.create_bidirectional_buffer(link)`\n2. Rust node: Buffer lifecycle management — create/accept streams, handle EOF, write/read API\n3. Verify bidirectional buffer streaming works (small data first, then multi-chunk)\n4. Test compression (data \u003e 32 bytes triggers compression heuristic)","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-13T20:58:04.541964678Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T21:44:19.945506466Z","closed_at":"2026-02-13T21:44:19.945506466Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-3a5.8","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-13T20:58:04.542710058Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-49z","title":"Refactor IFAC masking to use iterator chain (reticulum-transport)","description":"type: task","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-12T23:01:53.163542329-05:00","updated_at":"2026-02-13T15:12:55.118332877Z","closed_at":"2026-02-13T15:12:55.118334517Z"}
{"id":"Rusticulum-7pn","title":"Code Quality and Rust Best Practices","description":"Issues identified during comprehensive code quality review. Covers async safety, error handling, API design, and functional style improvements across all crates. Organized by severity: HIGH (async safety, missing bounds checks), MEDIUM (panics in production, API design), LOW (style and allocation improvements).","status":"open","priority":2,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-12T23:00:44.375304838-05:00","created_by":"Matthew Remmel","updated_at":"2026-02-12T23:00:44.375304838-05:00"}
{"id":"Rusticulum-8a9","title":"Remove unnecessary \u0026mut self where interior mutability suffices (cross-crate)","description":"type: task","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-12T23:01:53.157045537-05:00","updated_at":"2026-02-13T15:45:17.251472444Z","closed_at":"2026-02-13T15:45:17.251472444Z","close_reason":"Closed"}
{"id":"Rusticulum-97m","title":"Workspace \u0026 Project Setup","description":"Set up the Cargo workspace with all six crates (reticulum-crypto, reticulum-core, reticulum-protocol, reticulum-transport, reticulum-interfaces, reticulum-node), workspace-level dependencies, test vector infrastructure, and CI/tooling configuration. This is the foundation everything else builds on.","status":"closed","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:36.994738678Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:29:04.267935893Z","closed_at":"2026-02-12T18:29:04.267935893Z","close_reason":"Closed"}
{"id":"Rusticulum-97m.1","title":"Initialize Cargo workspace with all six crates","description":"Create the top-level Cargo.toml with [workspace] configuration listing all six member crates: reticulum-crypto, reticulum-core, reticulum-protocol, reticulum-transport, reticulum-interfaces, reticulum-node. Set up workspace-level dependency versions for all shared dependencies as specified in the implementation plan Part 6:\n\nCrypto: sha2=0.10, hmac=0.12, hkdf=0.12, aes=0.8, cbc=0.1, x25519-dalek=2, ed25519-dalek=2, rand=0.8\nSerialization: serde=1 (with derive), serde_json=1, rmpv=1, hex=0.4\nAsync: tokio=1 (full features)\nCompression: bzip2=0.4\nError: thiserror=2\nLogging: tracing=0.1\nCLI: clap=4 (derive feature)\nTesting: criterion=0.5, proptest (for property-based tests)\n\nEach crate gets its own Cargo.toml inheriting workspace dependencies. Set edition=2024 for all crates. Create minimal lib.rs files for each crate. The dependency graph is:\n- reticulum-crypto: leaf crate, no internal deps\n- reticulum-core: depends on reticulum-crypto\n- reticulum-protocol: depends on reticulum-core\n- reticulum-transport: depends on reticulum-protocol\n- reticulum-interfaces: depends on reticulum-core (for framing)\n- reticulum-node: depends on all other crates\n\nAcceptance: 'cargo build' succeeds with all crates, 'cargo test' runs (even if no tests yet).","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:04.340866205Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T17:51:34.505370731Z","closed_at":"2026-02-12T17:51:34.505370731Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.1","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:04.341533033Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m.2","title":"Set up no_std feature flags for crypto and core crates","description":"Configure reticulum-crypto and reticulum-core Cargo.toml files with optional no_std support:\n\n[features]\ndefault = ['std']\nstd = []\n\nWhen std is disabled, use #![no_std] with extern crate alloc. Ensure all types use alloc::vec::Vec, alloc::string::String instead of std equivalents. Add conditional compilation attributes throughout. Avoid std::time, std::net, etc. in these crates.\n\nAcceptance: Both crates compile with --no-default-features (once they have content).","status":"closed","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:07.745225569Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:00:34.972903124Z","closed_at":"2026-02-12T18:00:34.972903124Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.2","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:07.745764971Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-97m.2","depends_on_id":"Rusticulum-97m.1","type":"blocks","created_at":"2026-02-08T03:16:34.915916706Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m.3","title":"Set up test vector infrastructure","description":"Create the test vector loading infrastructure. The .test-vectors/ directory contains 17 JSON files. Create a shared test utilities module or approach for loading test vectors using include_str!() and serde_json::from_str().\n\nDefine serde-deserializable structs for each test vector file format (can be in a test-support module or within each crate's test modules). The schemas are defined in the implementation plan Part 5:\n\n- hashes.json: sha256_vectors/sha512_vectors arrays with input/expected fields\n- keypairs.json: keypairs array with all key material, signature_vectors, shared_secrets\n- hkdf.json: rfc5869_vectors array with ikm/salt/info/length/prk/okm, reticulum_vector\n- token.json: pkcs7_padding, hmac_sha256, encryption_vectors arrays\n- destination_hashes.json: single_destinations array\n- packet_headers.json: header_vectors array with flag byte layouts\n- packets_data.json: packet data arrays\n- announces.json: valid_announces array\n- links.json: handshake_vectors array\n- interface_framing.json: hdlc and kiss sections\n- channels.json: envelope_vectors, window_thresholds\n- resources.json: advertisement_vectors\n- resource_transfers.json: transfers array\n- buffer_transfers.json: small_transfer_vectors\n- retry_timers.json: keepalive/retry timing data\n- window_adaptation.json: window growth/shrink data\n- path_requests.json / path_expiration.json: path table test data\n- multi_hop_routing.json: routing test data\n- requests.json: request/response format data\n\nAll hex-encoded fields should be decoded with hex::decode(). Test pattern: load via include_str!, deserialize, iterate vectors, assert.\n\nAcceptance: Test vector structs compile and can successfully deserialize all 17 JSON files.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:21.982222473Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:28:57.884733118Z","closed_at":"2026-02-12T18:28:57.884733118Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.3","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:21.982767805Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-97m.3","depends_on_id":"Rusticulum-97m.1","type":"blocks","created_at":"2026-02-08T03:16:34.934704118Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m.4","title":"Configure CI quality gates","description":"Set up CI configuration (GitHub Actions or similar) with the following quality gates:\n\n- cargo fmt --check (formatting)\n- cargo clippy -- -D warnings (linting, deny warnings)\n- cargo test (all tests pass)\n- cargo test with --no-default-features for crypto and core crates (no_std compat)\n- cargo doc --no-deps (documentation builds)\n\nAlso configure:\n- Rust toolchain pinning (stable channel)\n- Caching for faster builds\n- Test coverage reporting (cargo-tarpaulin or similar)\n\nAcceptance: CI pipeline runs all checks and reports pass/fail status.","status":"closed","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:26.187881257Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:02:21.889730697Z","closed_at":"2026-02-12T18:02:21.889730697Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.4","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:26.188490062Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-97m.4","depends_on_id":"Rusticulum-97m.1","type":"blocks","created_at":"2026-02-08T03:16:34.953267291Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m.5","title":"Set up tracing infrastructure","description":"Configure tracing infrastructure across all crates. Add tracing as a workspace dependency. Set up:\n\n- tracing subscriber configuration in reticulum-node (the top-level orchestrator)\n- Structured logging with appropriate log levels:\n  - ERROR: Unrecoverable failures, protocol violations\n  - WARN: Recoverable errors, unexpected but handled conditions\n  - INFO: High-level protocol events (link established, announce received, resource transfer complete)\n  - DEBUG: Detailed protocol state changes, packet parsing, crypto operations\n  - TRACE: Wire-level data, raw bytes, individual state machine transitions\n- Use tracing::instrument on key functions\n- Span-based context for operations (per-link, per-resource, per-interface)\n- In no_std crates (crypto, core): use tracing behind a feature flag so it compiles without std\n\nAcceptance: Tracing compiles in all crates, log output is structured and filterable by level.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:30.363915011Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:01:49.345993377Z","closed_at":"2026-02-12T18:01:49.345993377Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.5","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:30.364415182Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-97m.5","depends_on_id":"Rusticulum-97m.1","type":"blocks","created_at":"2026-02-08T03:16:34.97221265Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-a43","title":"Avoid RawPacket clone in forwarding hot path (reticulum-node)","description":"type: task","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-12T23:01:53.158450539-05:00","updated_at":"2026-02-13T15:12:55.068326796Z","closed_at":"2026-02-13T15:12:55.068329036Z"}
{"id":"Rusticulum-arq","title":"Refactor AnnounceTable::insert to use a config struct (reticulum-transport)","description":"type: task","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-12T23:01:53.155624633-05:00","updated_at":"2026-02-13T15:12:55.102094538Z","closed_at":"2026-02-13T15:12:55.102096098Z"}
{"id":"Rusticulum-bha","title":"Core Types and Wire Formats (reticulum-core)","description":"Implement protocol types, constants, identity/addressing, packet wire formats, framing (HDLC/KISS), and announce construction/validation. All types use strong newtypes to prevent mixing raw byte arrays. Wire format tests must be bidirectional (parse raw → verify fields, serialize fields → compare bytes). Depends on reticulum-crypto. Should support optional no_std with alloc.","status":"closed","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:45.333562842Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.431517458Z","closed_at":"2026-02-12T19:48:29.431517458Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha","depends_on_id":"Rusticulum-sed","type":"blocks","created_at":"2026-02-08T03:15:08.618941216Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.1","title":"Implement protocol constants module","description":"Define all protocol constants in a dedicated constants module:\n\npub const MTU: usize = 500;                    // Maximum transmission unit\npub const HEADER_MINSIZE: usize = 19;          // HEADER_1 size\npub const HEADER_MAXSIZE: usize = 37;          // HEADER_2 size  \npub const MDU: usize = 462;                    // Max data unit: MTU - HEADER_MAXSIZE - 1\npub const TRUNCATED_HASHLENGTH: usize = 16;    // Destination/identity hash length\npub const HASHLENGTH: usize = 32;              // Full SHA-256 hash\npub const KEYSIZE: usize = 64;                 // 32 X25519 + 32 Ed25519\npub const SIGLENGTH: usize = 64;              // Ed25519 signature\npub const NAME_HASH_LENGTH: usize = 10;        // Truncated app name hash\npub const TOKEN_OVERHEAD: usize = 48;          // 16 IV + 32 HMAC\npub const ECPUBSIZE: usize = 64;               // Ephemeral pub in link request\n\nAlso define enums/constants for:\n- HEADER_1 = 0, HEADER_2 = 1 (header types)\n- BROADCAST = 0, TRANSPORT = 1 (transport types)\n- Destination types: SINGLE=0b00, GROUP=0b01, PLAIN=0b10, LINK=0b11\n- Packet types: DATA=0b00, ANNOUNCE=0b01, LINKREQUEST=0b10, PROOF=0b11\n\nThese should be compile-time constants with appropriate types. Add doc comments explaining each constant's role in the protocol.\n\nAcceptance: Constants module compiles, values match implementation plan Part 1 table.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:25:51.118247306Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.221622934Z","closed_at":"2026-02-12T19:48:29.221622934Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.1","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:25:51.118891383Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.10","title":"Implement Announce construction and validation","description":"Implement announce packet construction and validation:\n\nAnnounce signed_data construction (implementation plan Part 8 point 6):\n  signed_data = dest_hash(16) + public_key(64) + name_hash(10) + random_hash(10) + [ratchet(32)] + [app_data]\n  NOTE: destination_hash is the FIRST field in signed_data but is NOT part of the wire payload!\n\nRandom hash (Part 8 point 7):\n  random_hash = random_bytes(5) + timestamp_bytes(5)  (10 bytes total)\n  timestamp_bytes = current_unix_timestamp as big-endian 5 bytes\n\nAnnounce wire payload (what goes in the packet data field):\n  payload = public_key(64) + name_hash(10) + random_hash(10) + [ratchet(32)] + [app_data] + signature(64)\n\npub struct Announce {\n    pub destination_hash: DestinationHash,\n    pub public_key: PublicKey,\n    pub name_hash: NameHash,\n    pub random_hash: [u8; 10],\n    pub ratchet: Option\u003c[u8; 32]\u003e,\n    pub app_data: Option\u003cVec\u003cu8\u003e\u003e,\n    pub signature: Signature,\n}\n\nimpl Announce {\n    // Construction (for sending)\n    pub fn create(identity: \u0026Identity, destination: \u0026Destination, app_data: Option\u003c\u0026[u8]\u003e, ratchet: Option\u003c\u0026[u8; 32]\u003e) -\u003e Result\u003cSelf, AnnounceError\u003e;\n    // For deterministic testing:\n    pub fn create_deterministic(identity: \u0026Identity, destination: \u0026Destination, app_data: Option\u003c\u0026[u8]\u003e, ratchet: Option\u003c\u0026[u8; 32]\u003e, random_hash: \u0026[u8; 10]) -\u003e Result\u003cSelf, AnnounceError\u003e;\n    \n    // Validation (for receiving)\n    pub fn from_payload(destination_hash: \u0026DestinationHash, payload: \u0026[u8]) -\u003e Result\u003cSelf, AnnounceError\u003e;\n    pub fn validate(\u0026self) -\u003e bool;  // Verify signature against signed_data\n    \n    // Serialization\n    pub fn to_payload(\u0026self) -\u003e Vec\u003cu8\u003e;  // Wire payload (without dest_hash)\n    pub fn signed_data(\u0026self) -\u003e Vec\u003cu8\u003e;  // Full signed data (with dest_hash)\n    \n    // Build full raw packet\n    pub fn to_raw_packet(\u0026self, hops: u8) -\u003e Vec\u003cu8\u003e;\n}\n\nTest against announces.json -\u003e valid_announces:\n- Array of {keypair_index, app_name, aspects, name_hash, destination_hash, random_hash, ratchet (optional), signed_data, signature, announce_payload, flags_byte, raw_packet, packet_hash}\n- For each vector:\n  1. Load identity from keypairs.json[keypair_index]\n  2. Create announce deterministically with known random_hash\n  3. Verify signed_data matches expected\n  4. Verify signature matches expected\n  5. Verify announce_payload matches expected\n  6. Verify raw_packet matches expected (full packet with header)\n  7. Verify packet_hash matches expected\n  8. Parse announce from payload, validate signature\n\nAdd tracing::info! for announce creation, debug! for validation.\n\nProperty tests:\n- Created announce always validates successfully\n- Announce with corrupted signature fails validation\n- Announce payload always contains public_key + name_hash + random_hash + signature\n- Round-trip: from_payload(to_payload(announce)) preserves all fields\n\nAcceptance: All announces.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:38.984227124Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.395905647Z","closed_at":"2026-02-12T19:48:29.395905647Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.10","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:38.984813998Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.10","depends_on_id":"Rusticulum-bha.3","type":"blocks","created_at":"2026-02-08T03:28:32.847325416Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.10","depends_on_id":"Rusticulum-bha.4","type":"blocks","created_at":"2026-02-08T03:28:32.866891233Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.10","depends_on_id":"Rusticulum-bha.7","type":"blocks","created_at":"2026-02-08T03:28:32.886905499Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.11","title":"Implement error types for core crate","description":"Define comprehensive error types using thiserror for the core crate:\n\n#[derive(Debug, thiserror::Error)]\npub enum PacketError {\n    #[error(\"packet too short: {0} bytes, minimum {1}\")]\n    TooShort(usize, usize),\n    #[error(\"invalid header type: {0}\")]\n    InvalidHeaderType(u8),\n    #[error(\"invalid context type: {0:#x}\")]\n    InvalidContextType(u8),\n    #[error(\"invalid destination hash length\")]\n    InvalidDestinationHash,\n    // ... other variants\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum IdentityError {\n    #[error(\"no private key available\")]\n    NoPrivateKey,\n    #[error(\"invalid key length: expected {expected}, got {got}\")]\n    InvalidKeyLength { expected: usize, got: usize },\n    #[error(\"decryption failed\")]\n    DecryptionFailed,\n    #[error(\"signature verification failed\")]\n    SignatureVerificationFailed,\n    // ...\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum FramingError {\n    #[error(\"missing frame delimiter\")]\n    MissingDelimiter,\n    #[error(\"incomplete escape sequence\")]\n    IncompleteEscape,\n    // ...\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum AnnounceError { ... }\n\nAlso define CryptoError in reticulum-crypto crate:\n#[derive(Debug, thiserror::Error)]\npub enum CryptoError {\n    #[error(\"invalid padding\")]\n    InvalidPadding,\n    #[error(\"HMAC verification failed\")]\n    HmacVerificationFailed,\n    #[error(\"ciphertext too short\")]\n    CiphertextTooShort,\n    #[error(\"invalid key length\")]\n    InvalidKeyLength,\n    // ...\n}\n\nAll errors should include enough context for debugging. Use tracing::warn! or error! when errors are created.\n\nAcceptance: All error types compile, provide useful messages, integrate with ? operator.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:48.983964629Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.413592463Z","closed_at":"2026-02-12T19:48:29.413592463Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.11","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:48.984619066Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.2","title":"Implement newtype wrappers for protocol byte arrays","description":"Implement strong newtype wrappers to prevent mixing raw byte arrays. Each type wraps a fixed-size byte array and implements standard traits:\n\nCore hash types:\n- TruncatedHash([u8; 16]) - implements Copy, Clone, Eq, PartialEq, Hash, AsRef\u003c[u8]\u003e, TryFrom\u003c\u0026[u8]\u003e, Display (hex), Debug, serde Serialize/Deserialize\n- FullHash([u8; 32]) - same traits\n- NameHash([u8; 10]) - same traits\n\nProtocol-specific newtypes (wrapping TruncatedHash or FullHash):\n- DestinationHash(TruncatedHash) - 16-byte destination hash\n- IdentityHash(TruncatedHash) - 16-byte identity hash\n- LinkId(TruncatedHash) - 16-byte link identifier\n- PacketHash(FullHash) - 32-byte packet hash\n- Signature([u8; 64]) - Ed25519 signature (SIGLENGTH=64)\n\nKey types:\n- X25519Pub([u8; 32]) - X25519 public key\n- Ed25519Pub([u8; 32]) - Ed25519 public key\n- PublicKey { encryption: X25519Pub, signing: Ed25519Pub } - combined public key (KEYSIZE=64 bytes total)\n\nAll types must implement:\n- TryFrom\u003c\u0026[u8]\u003e with proper length validation and error\n- AsRef\u003c[u8]\u003e for easy byte access\n- Display showing hex encoding (lowercase)\n- Debug showing abbreviated hex (first 4 bytes + '...')\n- serde Serialize/Deserialize (as hex strings)\n- From\u003c[u8; N]\u003e for direct construction from fixed-size arrays\n\nAdd tracing::trace! where appropriate for type conversions.\n\nProperty tests:\n- TryFrom rejects wrong-length slices\n- Round-trip: TryFrom(type.as_ref()) == original\n- Display output is valid hex and correct length\n- Serde round-trip: deserialize(serialize(x)) == x\n\nAcceptance: All newtypes compile with correct trait implementations, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:04.563885038Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.252141439Z","closed_at":"2026-02-12T19:48:29.252141439Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.2","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:04.56442761Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.2","depends_on_id":"Rusticulum-bha.1","type":"blocks","created_at":"2026-02-08T03:28:07.530714901Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.3","title":"Implement Identity struct with key management","description":"Implement the Identity struct supporting both full (private+public) and public-only modes:\n\npub struct Identity { /* private fields */ }\n\nimpl Identity {\n    // Construction\n    pub fn generate() -\u003e Self;  // Generate new random keypair\n    pub fn from_private_bytes(bytes: \u0026[u8; 64]) -\u003e Result\u003cSelf, IdentityError\u003e;  // 32 X25519 prv + 32 Ed25519 prv\n    pub fn from_public_bytes(bytes: \u0026[u8; 64]) -\u003e Result\u003cSelf, IdentityError\u003e;   // 32 X25519 pub + 32 Ed25519 pub\n    \n    // Accessors\n    pub fn hash(\u0026self) -\u003e IdentityHash;  // SHA256(x25519_pub || ed25519_pub)[0:16]\n    pub fn public_key(\u0026self) -\u003e PublicKey;\n    pub fn has_private_key(\u0026self) -\u003e bool;\n    \n    // Crypto operations (require private key)\n    pub fn sign(\u0026self, message: \u0026[u8]) -\u003e Result\u003cSignature, IdentityError\u003e;\n    pub fn verify(\u0026self, signature: \u0026Signature, message: \u0026[u8]) -\u003e bool;  // works with public-only too\n    \n    // Encryption (public key envelope encryption)\n    pub fn encrypt(\u0026self, plaintext: \u0026[u8], ratchet: Option\u003c\u0026[u8; 32]\u003e) -\u003e Result\u003cVec\u003cu8\u003e, IdentityError\u003e;\n    pub fn decrypt(\u0026self, ciphertext: \u0026[u8], ratchets: \u0026[[u8; 32]]) -\u003e Result\u003cVec\u003cu8\u003e, IdentityError\u003e;\n}\n\nIdentity hash computation:\n  identity_hash = SHA256(x25519_pub || ed25519_pub)[0:16]\n\nIdentity encryption (envelope):\n1. Generate ephemeral X25519 keypair\n2. ECDH: shared_secret = ephemeral_prv.exchange(target_pub_or_ratchet)\n3. derived_key = HKDF(length=64, ikm=shared_secret, salt=identity_hash, info=b'')\n4. token = Token(derived_key).encrypt(plaintext)\n5. output = ephemeral_pub(32) || token(48+ bytes)\n\nFor deterministic testing, provide internal method that accepts pre-generated ephemeral key.\n\nTest against keypairs.json:\n- Load each keypair's private_key (64 bytes = x25519_prv || ed25519_prv)\n- Derive public key, verify matches public_key field\n- Compute identity_hash, verify matches identity_hash field\n- Sign/verify using signature_vectors\n\nAdd tracing::info! for key generation, debug! for hash computation and crypto ops.\n\nProperty tests:\n- Generated identity always has private key\n- Public-only identity returns error on sign\n- identity_hash is deterministic from public key\n- encrypt then decrypt round-trips successfully\n- decrypt fails with wrong identity\n\nAcceptance: All keypairs.json identity vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:20.305460347Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.270484951Z","closed_at":"2026-02-12T19:48:29.270484951Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.3","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:20.30603265Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.3","depends_on_id":"Rusticulum-bha.2","type":"blocks","created_at":"2026-02-08T03:28:11.573491199Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.4","title":"Implement Destination hashing","description":"Implement destination hash computation:\n\npub enum DestinationType { Single, Group, Plain, Link }\n\npub struct Destination {\n    identity: Option\u003cIdentityHash\u003e,\n    app_name: String,\n    aspects: Vec\u003cString\u003e,\n    dtype: DestinationType,\n}\n\nimpl Destination {\n    pub fn name_hash(app_name: \u0026str, aspects: \u0026[\u0026str]) -\u003e NameHash;\n    pub fn hash(\u0026self) -\u003e DestinationHash;\n}\n\nHash computation:\n  name_hash = SHA256('app_name.aspect1.aspect2'.encode('utf-8'))[0:10]   (10 bytes, NAME_HASH_LENGTH)\n  destination_hash = SHA256(name_hash || identity_hash)[0:16]             (16 bytes, TRUNCATED_HASHLENGTH)\n\nThe full app name string is constructed by joining app_name and all aspects with '.' separator.\n\nTest against destination_hashes.json -\u003e single_destinations:\n- Array of {app_name, aspects (array of strings), name_hash (hex, 10 bytes), identity_hash (hex), addr_hash_material (hex = name_hash || identity_hash), destination_hash (hex), keypair_index}\n- For each vector:\n  1. Compute name_hash from app_name + aspects, verify matches\n  2. Load identity from keypairs.json[keypair_index], compute identity_hash, verify matches\n  3. Verify addr_hash_material = name_hash || identity_hash\n  4. Compute destination_hash, verify matches\n\nAdd tracing::debug! for destination hash computation showing app name and result.\n\nProperty tests:\n- name_hash is always 10 bytes\n- destination_hash is always 16 bytes\n- Different app names produce different name hashes\n- Same app_name + aspects always produce same name_hash\n\nAcceptance: All destination_hashes.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:29.879022323Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.288476029Z","closed_at":"2026-02-12T19:48:29.288476029Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.4","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:29.879739132Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.4","depends_on_id":"Rusticulum-bha.2","type":"blocks","created_at":"2026-02-08T03:28:15.911721264Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.4","depends_on_id":"Rusticulum-bha.3","type":"blocks","created_at":"2026-02-08T03:28:15.93296796Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.5","title":"Implement packet flags encoding/decoding","description":"Implement PacketFlags - single byte encode/decode for packet header flags:\n\npub struct PacketFlags {\n    pub header_type: HeaderType,       // Bit 7: 0=HEADER_1, 1=HEADER_2\n    pub context_flag: bool,            // Bit 6: context flag\n    pub transport_type: TransportType, // Bit 5: 0=BROADCAST, 1=TRANSPORT\n    pub destination_type: DestinationType, // Bits 4-3\n    pub packet_type: PacketType,       // Bits 1-0 (note: bits 1-0, NOT 2-1)\n}\n\nBit layout of flags byte:\n  Bit 7:    header_type   (0=HEADER_1, 1=HEADER_2)\n  Bit 6:    context_flag  (0=unset, 1=set)\n  Bit 5:    transport_type (0=BROADCAST, 1=TRANSPORT)\n  Bits 4-3: destination_type (00=SINGLE, 01=GROUP, 10=PLAIN, 11=LINK)\n  Bits 1-0: packet_type (00=DATA, 01=ANNOUNCE, 10=LINKREQUEST, 11=PROOF)\n\nNote: Bit 2 is unused/reserved (always 0).\n\nimpl PacketFlags {\n    pub fn from_byte(byte: u8) -\u003e Self;\n    pub fn to_byte(\u0026self) -\u003e u8;\n}\n\nTest against packet_headers.json -\u003e header_vectors:\n- Array of {flags_byte (int), header_type, packet_type, destination_type, transport_type, context_flag, ...}\n- For each vector: decode flags_byte, verify all field values match\n- Re-encode to byte, verify matches original flags_byte\n\nAlso test against packet_headers.json -\u003e flag_byte_layout, packet_type_values, context_type_values for enum value correctness.\n\nAdd tracing::trace! for flags parsing.\n\nProperty tests:\n- Round-trip: from_byte(to_byte(flags)) == flags\n- to_byte produces values 0-255\n- Bit 2 is always 0\n\nAcceptance: All packet_headers.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:40.618140718Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.306498799Z","closed_at":"2026-02-12T19:48:29.306498799Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.5","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:40.618692791Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.5","depends_on_id":"Rusticulum-bha.1","type":"blocks","created_at":"2026-02-08T03:28:23.902058349Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.6","title":"Implement ContextType enum","description":"Implement the ContextType enum representing all packet context values:\n\npub enum ContextType {\n    None = 0x00,\n    Resource = 0x01,\n    ResourceAdv = 0x02,\n    ResourceReq = 0x03,\n    ResourceHmu = 0x04,\n    ResourceIcl = 0x05,\n    ResourceRcl = 0x06,\n    Channel = 0x07,\n    Keepalive = 0xFA,\n    LinkIdentify = 0xFB,\n    LinkClose = 0xFC,\n    LinkProof = 0xFD,\n    LRProof = 0xFE,\n    LRRtt = 0xFF,\n    // Add any others from packet_headers.json context_type_values\n}\n\nimpl ContextType {\n    pub fn from_byte(byte: u8) -\u003e Result\u003cSelf, PacketError\u003e;\n    pub fn to_byte(\u0026self) -\u003e u8;\n}\n\nTest against packet_headers.json -\u003e context_type_values to verify all context types are defined with correct numeric values.\n\nAcceptance: All context types from test vectors are represented, bidirectional conversion works.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:47.870063166Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.324762078Z","closed_at":"2026-02-12T19:48:29.324762078Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.6","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:47.870813387Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.6","depends_on_id":"Rusticulum-bha.1","type":"blocks","created_at":"2026-02-08T03:28:23.921738991Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.7","title":"Implement RawPacket parsing and serialization","description":"Implement zero-copy packet parsing and serialization:\n\npub struct RawPacket\u003c'a\u003e {\n    pub flags: PacketFlags,\n    pub hops: u8,\n    pub transport_id: Option\u003cDestinationHash\u003e,  // Present only for HEADER_2\n    pub destination: DestinationHash,\n    pub context: ContextType,\n    pub data: \u0026'a [u8],\n}\n\nHEADER_1 layout (19+ bytes): flags(1) + hops(1) + dest_hash(16) + context(1) + data(...)\nHEADER_2 layout (35+ bytes): flags(1) + hops(1) + transport_id(16) + dest_hash(16) + context(1) + data(...)\n\nimpl\u003c'a\u003e RawPacket\u003c'a\u003e {\n    pub fn parse(raw: \u0026'a [u8]) -\u003e Result\u003cSelf, PacketError\u003e;\n    pub fn serialize(\u0026self) -\u003e Vec\u003cu8\u003e;\n    pub fn hashable_part(\u0026self) -\u003e Vec\u003cu8\u003e;\n    pub fn packet_hash(\u0026self) -\u003e PacketHash;\n}\n\nCRITICAL - hashable_part computation (implementation plan Part 8 point 4):\n- Flags byte is masked to (flags \u0026 0x0F) - keep only destination_type and packet_type (lower 4 bits)\n- Hops byte is EXCLUDED\n- For HEADER_2: transport_id is EXCLUDED\n- Result: masked_flags(1) + dest_hash(16) + context(1) + data(...)\n\npacket_hash = SHA256(hashable_part) (full 32 bytes)\n\nParse must validate:\n- Minimum length (HEADER_MINSIZE=19 for HEADER_1, HEADER_MAXSIZE=37 for HEADER_2)  \n- Header type determines whether transport_id is present\n\nTest against packets_data.json (or similar packet test vector file):\n- Parse raw packet bytes, verify all fields match expected\n- Serialize from fields, verify matches original raw bytes (bidirectional!)\n- Compute hashable_part and packet_hash, verify against expected\n\nAdd tracing::debug! for packet parsing (destination, type, data length), trace! for raw bytes.\n\nProperty tests:\n- parse(serialize(packet)) == packet (round-trip)\n- hashable_part always has masked flags (upper 4 bits = 0 except for dest_type bits)\n- hashable_part never contains hops byte\n- HEADER_1 packets serialize to \u003e= 19 bytes\n- HEADER_2 packets serialize to \u003e= 35 bytes\n\nAcceptance: All packet test vectors pass bidirectionally, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:01.674582246Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.342572438Z","closed_at":"2026-02-12T19:48:29.342572438Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.7","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:01.675211462Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.7","depends_on_id":"Rusticulum-bha.2","type":"blocks","created_at":"2026-02-08T03:28:28.150827077Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.7","depends_on_id":"Rusticulum-bha.5","type":"blocks","created_at":"2026-02-08T03:28:28.171186447Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.7","depends_on_id":"Rusticulum-bha.6","type":"blocks","created_at":"2026-02-08T03:28:28.190693062Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.8","title":"Implement HDLC framing","description":"Implement HDLC byte-stuffing framing for interface communication:\n\nConstants:\n  FLAG: u8 = 0x7E\n  ESC: u8 = 0x7D\n  ESC_MASK: u8 = 0x20\n\npub fn hdlc_frame(data: \u0026[u8]) -\u003e Vec\u003cu8\u003e;\npub fn hdlc_unframe(framed: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, FramingError\u003e;\n\nFrame algorithm:\n1. Start with FLAG byte (0x7E)\n2. For each data byte:\n   - If byte == ESC (0x7D): output ESC, then (byte XOR ESC_MASK) = 0x5D\n   - If byte == FLAG (0x7E): output ESC, then (byte XOR ESC_MASK) = 0x5E\n   - Otherwise: output byte as-is\n3. End with FLAG byte (0x7E)\n\nCRITICAL escape order (implementation plan Part 8 point 5):\n  ESC bytes (0x7D) MUST be escaped BEFORE FLAG bytes (0x7E).\n  Reversing this order corrupts data containing ESC bytes.\n\nUnframe algorithm:\n1. Strip leading/trailing FLAG bytes\n2. Process escape sequences: ESC followed by byte -\u003e (byte XOR ESC_MASK)\n3. Return unescaped data\n\nTest against interface_framing.json -\u003e hdlc -\u003e vectors:\n- Array of {raw (hex), framed (hex), description}\n- Frame raw data, verify matches framed\n- Unframe framed data, verify matches raw\n\nAdd tracing::trace! for frame/unframe showing data lengths.\n\nProperty tests:\n- Round-trip: unframe(frame(data)) == data for any input\n- Framed output always starts and ends with FLAG (0x7E)\n- Framed output never contains unescaped FLAG or ESC bytes in the middle\n- Frame of empty data is just FLAG + FLAG\n- Data containing FLAG bytes produces longer output than data without\n\nEdge cases: empty data, data that is all FLAG bytes, data that is all ESC bytes, data with ESC followed by FLAG.\n\nAcceptance: All interface_framing.json hdlc vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:14.115288039Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.360422381Z","closed_at":"2026-02-12T19:48:29.360422381Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.8","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:14.115827891Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.9","title":"Implement KISS framing","description":"Implement KISS byte-stuffing framing:\n\nConstants:\n  FEND: u8 = 0xC0\n  FESC: u8 = 0xDB\n  TFEND: u8 = 0xDC\n  TFESC: u8 = 0xDD\n\npub fn kiss_frame(data: \u0026[u8]) -\u003e Vec\u003cu8\u003e;\npub fn kiss_unframe(framed: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, FramingError\u003e;\n\nFrame algorithm:\n1. Start with FEND byte (0xC0)\n2. For each data byte:\n   - If byte == FEND (0xC0): output FESC + TFEND (0xDB, 0xDC)\n   - If byte == FESC (0xDB): output FESC + TFESC (0xDB, 0xDD)\n   - Otherwise: output byte as-is\n3. End with FEND byte (0xC0)\n\nUnframe: reverse the process, strip FEND delimiters, decode escape sequences.\n\nTest against interface_framing.json -\u003e kiss -\u003e vectors (if present):\n- Same pattern as HDLC: frame raw, compare with expected; unframe framed, compare with raw\n\nAdd tracing::trace! for frame/unframe showing data lengths.\n\nProperty tests:\n- Round-trip: unframe(frame(data)) == data\n- Framed output always starts and ends with FEND\n- No unescaped FEND or FESC in middle of framed output\n\nAcceptance: All KISS vectors pass (if present), proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:21.449172904Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.377962701Z","closed_at":"2026-02-12T19:48:29.377962701Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.9","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:21.449734187Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u","title":"Protocol State Machines (reticulum-protocol)","description":"Implement all protocol state machines: Link handshake (type-state pattern: Pending→Handshake→Active→Closed), MTU signalling, keepalive, Channel (envelopes, sequencing, window control), Resource (advertisement, windowing, hashmap, transfer, segmentation), Buffer (stream protocol, compression), and Request/Response. State machines produce Vec\u003cu8\u003e actions, never perform I/O directly. Depends on reticulum-core.","status":"closed","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:49.049339967Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T00:54:39.336509945Z","closed_at":"2026-02-13T00:54:39.336509945Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u","depends_on_id":"Rusticulum-bha","type":"blocks","created_at":"2026-02-08T03:15:08.637876783Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.1","title":"Implement Link state types and type-state pattern","description":"Implement the Link state machine using Rust's type-state pattern. Define separate types for each link state:\n\npub struct LinkPending {\n    // Ephemeral X25519 keypair (initiator) or received pub keys (responder)\n    // Ephemeral Ed25519 keypair\n    // Target destination\n    // Request timestamp\n}\n\npub struct LinkHandshake {\n    // Derived key (64 bytes)\n    // Token instance\n    // Peer's signing public key\n    // Link ID\n}\n\npub struct LinkActive {\n    // Token for encrypt/decrypt\n    // RTT measurement\n    // MDU (effective max data unit)\n    // Keepalive interval\n    // Last activity timestamp\n}\n\npub struct LinkClosed {\n    // Close reason\n    // Final statistics\n}\n\nFor runtime use where the state needs to be dynamic, provide:\npub enum LinkState {\n    Pending(LinkPending),\n    Handshake(LinkHandshake),\n    Active(LinkActive),\n    Closed(LinkClosed),\n}\n\nEach state type contains only the data relevant to that state. Transitions consume the old state and produce the new state (move semantics), ensuring invalid state transitions are compile-time errors.\n\nAdd tracing::info! for state transitions, debug! for state details.\n\nAcceptance: All state types compile, transitions are type-safe, LinkState enum wraps all states.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:08.807288044Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T20:08:03.055748683Z","closed_at":"2026-02-12T20:08:03.055748683Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.1","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:08.807997763Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.10","title":"Implement Resource hashmap and part tracking","description":"Implement the resource hashmap for tracking transfer parts:\n\nParts use 4-byte truncated hashes:\n  part_hash = SHA256(part_data)[0:4]\n\nHASHMAP_MAX_LEN = 74\n\npub struct ResourceHashmap {\n    parts: Vec\u003c[u8; 4]\u003e,  // 4-byte truncated hashes\n}\n\nimpl ResourceHashmap {\n    pub fn new() -\u003e Self;\n    pub fn add_part(\u0026mut self, data: \u0026[u8]) -\u003e [u8; 4];  // Returns 4-byte hash\n    pub fn to_bytes(\u0026self) -\u003e Vec\u003cu8\u003e;  // Concatenated 4-byte hashes (max 74 entries = 296 bytes)\n    pub fn from_bytes(data: \u0026[u8]) -\u003e Result\u003cSelf, ResourceError\u003e;\n    pub fn verify_part(\u0026self, index: usize, data: \u0026[u8]) -\u003e bool;\n    pub fn len(\u0026self) -\u003e usize;\n}\n\nHashmap segments: when parts exceed HASHMAP_MAX_LEN, split into multiple hashmap messages.\n\nTest against resource_transfers.json:\n- Compute 4-byte part hashes, verify against expected\n- Build hashmap segments, verify against expected\n\nAdd tracing::trace! for part hash computation.\n\nProperty tests:\n- Part hash is always 4 bytes\n- Hashmap bytes length == 4 * num_parts\n- Parts exceeding HASHMAP_MAX_LEN are correctly segmented\n- verify_part returns true for correct data, false for corrupted\n\nAcceptance: All resource_transfers.json hashmap vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:47.993124884Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:17:29.692525553Z","closed_at":"2026-02-12T22:17:29.692525553Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.10","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:47.993746859Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.11","title":"Implement Resource transfer simulation","description":"Implement full resource transfer lifecycle:\n\nStates: Queued -\u003e Advertised -\u003e Transferring -\u003e AwaitingProof -\u003e Complete\n\npub enum ResourceState {\n    Queued,\n    Advertised { advertisement: ResourceAdvertisement },\n    Transferring { window: WindowState, parts_sent: usize, parts_total: usize },\n    AwaitingProof { resource_hash: FullHash },\n    Complete,\n    Failed(ResourceError),\n}\n\nResource proof:\n  proof = SHA256(data || resource_hash)\n\nSegmentation for large resources:\n  MAX_EFFICIENT_SIZE = 1,048,575 bytes\n  Resources larger than this are split into segments\n\nPart encryption: each part is encrypted with the link's Token before transmission.\n\nTest against resource_transfers.json -\u003e transfers:\n- Array of {data_hex, advertisement, parts: [...], proof, derived_key}\n- For each transfer:\n  1. Create resource from data\n  2. Generate advertisement, verify matches\n  3. Split into parts, encrypt each with Token(derived_key)\n  4. Verify each encrypted part matches expected\n  5. Reassemble parts, decrypt, verify matches original data\n  6. Compute proof, verify matches expected\n\nAdd tracing::info! for transfer lifecycle events, debug! for part details.\n\nProperty tests:\n- All parts reassemble to original data\n- Proof is deterministic from data + resource_hash\n- Encrypted parts can be decrypted with correct key\n- Part count matches expected for given data size\n\nAcceptance: All resource_transfers.json transfer vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:33:00.557404493Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T00:01:36.456745445Z","closed_at":"2026-02-13T00:01:36.456745445Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:33:00.557951286Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u.8","type":"blocks","created_at":"2026-02-08T03:34:06.352908505Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u.9","type":"blocks","created_at":"2026-02-08T03:34:06.373900302Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u.10","type":"blocks","created_at":"2026-02-08T03:34:06.394714081Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u.5","type":"blocks","created_at":"2026-02-08T03:34:06.415090683Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.12","title":"Implement Buffer stream protocol","description":"Implement the Buffer stream protocol for streaming data over channels:\n\nStream header (2 bytes, big-endian):\n  Bit 15: EOF flag (1 = this is the last chunk)\n  Bit 14: compressed flag (1 = data is bz2 compressed)\n  Bits 13-0: stream_id (14-bit value, 0-16383)\n\npub struct StreamHeader {\n    pub is_eof: bool,\n    pub is_compressed: bool,\n    pub stream_id: u16,  // 14-bit\n}\n\nimpl StreamHeader {\n    pub fn encode(\u0026self) -\u003e [u8; 2];\n    pub fn decode(bytes: \u0026[u8; 2]) -\u003e Self;\n}\n\nBuffer message construction:\n  message = stream_header(2) + data_chunk(...)\n\nCompression: attempt bz2 compression with 4 retry attempts at decreasing sizes:\n  Try sizes: [full, 3/4, 1/2, 1/4] of the data\n  Use compressed version only if it is smaller than uncompressed\n\npub struct BufferMessage {\n    pub header: StreamHeader,\n    pub data: Vec\u003cu8\u003e,\n}\n\nimpl BufferMessage {\n    pub fn pack(\u0026self) -\u003e Vec\u003cu8\u003e;  // stream_header + data\n    pub fn unpack(bytes: \u0026[u8]) -\u003e Result\u003cSelf, BufferError\u003e;\n}\n\nTest against buffer_transfers.json -\u003e small_transfer_vectors:\n- Array of {data (hex), messages: [{chunk_hex, stream_packed_hex, envelope_packed_hex, compressed (bool), is_eof (bool), sequence (int), offset (int)}]}\n- For each transfer, verify:\n  1. Stream header encoding matches expected\n  2. Chunk data matches expected\n  3. Compression flag matches expected\n  4. EOF flag matches expected\n\nAdd tracing::debug! for buffer operations, trace! for compression attempts.\n\nProperty tests:\n- Stream header round-trip: decode(encode(header)) preserves all fields\n- stream_id fits in 14 bits (0-16383)\n- Compressed data decompresses to original (when compression is used)\n- EOF is set on the last message only\n\nAcceptance: All buffer_transfers.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:33:12.964546843Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T23:18:06.452630846Z","closed_at":"2026-02-12T23:18:06.452630846Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.12","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:33:12.965163408Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.12","depends_on_id":"Rusticulum-c7u.6","type":"blocks","created_at":"2026-02-08T03:34:10.586250684Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.13","title":"Implement Request/Response protocol","description":"Implement the Request/Response RPC-style protocol over links:\n\nRequest format (msgpack): [timestamp, path_hash, data]\nResponse format (msgpack): [request_id, data]\n\npub struct Request {\n    pub timestamp: f64,      // Unix timestamp\n    pub path_hash: Vec\u003cu8\u003e,  // Hash identifying the request path/endpoint\n    pub data: Vec\u003cu8\u003e,       // Request payload (msgpack-encoded)\n}\n\npub struct Response {\n    pub request_id: Vec\u003cu8\u003e,  // Links back to original request\n    pub data: Vec\u003cu8\u003e,        // Response payload\n}\n\nimpl Request {\n    pub fn to_msgpack(\u0026self) -\u003e Vec\u003cu8\u003e;\n    pub fn from_msgpack(data: \u0026[u8]) -\u003e Result\u003cSelf, RequestError\u003e;\n}\n\nimpl Response {\n    pub fn to_msgpack(\u0026self) -\u003e Vec\u003cu8\u003e;\n    pub fn from_msgpack(data: \u0026[u8]) -\u003e Result\u003cSelf, RequestError\u003e;\n}\n\nTest against requests.json:\n- Request/response msgpack encoding/decoding\n- Round-trip serialization\n\nAdd tracing::debug! for request/response operations.\n\nProperty tests:\n- Round-trip: from_msgpack(to_msgpack(request)) preserves fields\n- Timestamp is preserved with float precision\n\nAcceptance: All requests.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:33:20.416572532Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T00:54:31.402931668Z","closed_at":"2026-02-13T00:54:31.402931668Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.13","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:33:20.417124605Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.14","title":"Implement protocol error types","description":"Define error types for the protocol crate using thiserror:\n\n#[derive(Debug, thiserror::Error)]\npub enum LinkError {\n    #[error(\"handshake failed: {0}\")]\n    HandshakeFailed(String),\n    #[error(\"invalid proof: signature verification failed\")]\n    InvalidProof,\n    #[error(\"link not active\")]\n    NotActive,\n    #[error(\"encryption failed: {0}\")]\n    EncryptionFailed(#[from] CryptoError),\n    #[error(\"invalid state transition from {from} to {to}\")]\n    InvalidTransition { from: \u0026'static str, to: \u0026'static str },\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ChannelError { ... }\n\n#[derive(Debug, thiserror::Error)]\npub enum ResourceError { ... }\n\n#[derive(Debug, thiserror::Error)]\npub enum BufferError { ... }\n\n#[derive(Debug, thiserror::Error)]\npub enum RequestError { ... }\n\nAll errors should chain properly with #[from] for underlying crypto/packet errors.\n\nAcceptance: All error types compile, provide useful messages, support error chaining.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:33:27.908900412Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T20:08:03.076702382Z","closed_at":"2026-02-12T20:08:03.076702382Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.14","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:33:27.909427264Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.2","title":"Implement Link handshake initiator and responder","description":"Implement the 3-packet link handshake protocol:\n\nINITIATOR                                    RESPONDER\n    |                                            |\n    |-- LINKREQUEST [eph_x25519(32) +            |\n    |   eph_ed25519(32) + mtu_signal(3?)] ----\u003e |\n    |                                            |\n    |   link_id = SHA256(hashable_part)[0:16]    |\n    |   (strip mtu signalling from hashable)     |\n    |                                            |\n    | \u003c---- LRPROOF [signature(64) +             |\n    |        resp_x25519(32) + mtu_signal(3?)]   |\n    |                                            |\n    |   Both sides: ECDH -\u003e HKDF(64, shared,     |\n    |     salt=link_id) -\u003e Token(derived_key)    |\n    |                                            |\n    |-- LRRTT [Token.encrypt(msgpack(rtt))] ---\u003e |\n    |                                            |\n    |         === LINK ACTIVE ===                |\n\nInitiator side:\nimpl LinkPending {\n    pub fn new_initiator(destination: \u0026Destination) -\u003e (Self, Vec\u003cu8\u003e);  // returns LINKREQUEST data\n    // Deterministic version for testing:\n    pub fn new_initiator_deterministic(\n        destination: \u0026Destination,\n        eph_x25519_prv: \u0026[u8; 32],\n        eph_ed25519_prv: \u0026[u8; 32],\n    ) -\u003e (Self, Vec\u003cu8\u003e);\n    \n    pub fn receive_proof(self, proof_data: \u0026[u8], responder_identity: \u0026Identity)\n        -\u003e Result\u003c(LinkActive, Vec\u003cu8\u003e), LinkError\u003e;  // returns (active_link, LRRTT_data)\n}\n\nResponder side:\nimpl LinkPending {\n    pub fn new_responder(identity: \u0026Identity, link_request_data: \u0026[u8], destination: \u0026Destination)\n        -\u003e Result\u003c(LinkHandshake, Vec\u003cu8\u003e), LinkError\u003e;  // returns (handshake, LRPROOF_data)\n}\n\nimpl LinkHandshake {\n    pub fn receive_rtt(self, encrypted_rtt: \u0026[u8]) -\u003e Result\u003cLinkActive, LinkError\u003e;\n}\n\nKey derivation:\n1. shared_secret = initiator_eph_x25519.dh(responder_x25519_pub) [or vice versa]\n2. derived_key = HKDF(length=64, ikm=shared_secret, salt=link_id, info=b'')\n3. token = Token(derived_key)\n\nCRITICAL - Link ID computation (Part 8 point 3):\n- link_id = SHA256(hashable_part_of_LINKREQUEST)[0:16]\n- The hashable part only includes up to ECPUBSIZE (64) bytes of data\n- MTU signalling bytes must be STRIPPED before hashing\n\nLRPROOF data:\n- signature(64) = responder signs the link_request_data with Ed25519\n- + responder_x25519_pub(32) [ephemeral or static depending on implementation]\n- + optional mtu_signal(3)\n\nLRRTT data:\n- Token.encrypt(msgpack(rtt_measurement))\n\nTest against links.json -\u003e handshake_vectors:\n- Load initiator/responder keypairs\n- Create initiator with known ephemeral keys\n- Verify LINKREQUEST data matches expected\n- Verify link_id matches expected\n- Process LRPROOF, verify derived_key matches expected\n- Full handshake round-trip\n\nAdd tracing::info! for handshake milestones, debug! for key material (never log private keys at info level!).\n\nProperty tests:\n- Handshake between two random identities always succeeds\n- derived_key is always 64 bytes\n- link_id is always 16 bytes\n- Active link can encrypt/decrypt round-trip\n\nAcceptance: All links.json handshake vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:31.760131438Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T20:45:41.232691199Z","closed_at":"2026-02-12T20:45:41.232691199Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.2","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:31.760740793Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.2","depends_on_id":"Rusticulum-c7u.1","type":"blocks","created_at":"2026-02-08T03:33:48.403869667Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.2","depends_on_id":"Rusticulum-c7u.3","type":"blocks","created_at":"2026-02-08T03:33:48.424615474Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.3","title":"Implement MTU signalling encode/decode","description":"Implement MTU signalling that can be appended to link request/proof packets:\n\nMTU signalling encoding (Part 8 point 9):\n  3 bytes = big-endian 32-bit integer with first byte stripped\n  value = (mtu \u0026 0x1FFFFF) + (((mode \u003c\u003c 5) \u0026 0xE0) \u003c\u003c 16)\n  The mode occupies the top 3 bits of the first byte (of the 3-byte encoding)\n  The MTU occupies the lower 21 bits\n\npub struct MtuSignal {\n    pub mtu: u32,    // 21-bit MTU value (max 2,097,151)\n    pub mode: u8,    // 3-bit mode (0-7)\n}\n\nimpl MtuSignal {\n    pub fn encode(\u0026self) -\u003e [u8; 3];\n    pub fn decode(bytes: \u0026[u8; 3]) -\u003e Self;\n}\n\nTest against links.json -\u003e mtu_signalling (if present):\n- Encode known MTU/mode values, verify 3-byte output matches\n- Decode known 3-byte values, verify MTU and mode match\n\nAdd tracing::trace! for MTU signalling encode/decode.\n\nProperty tests:\n- Round-trip: decode(encode(signal)) == signal (for valid MTU/mode ranges)\n- MTU values up to 0x1FFFFF encode correctly\n- Mode values 0-7 encode correctly\n- Encoded output is always exactly 3 bytes\n\nAcceptance: All MTU signalling vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:42.236920422Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T20:32:07.359475516Z","closed_at":"2026-02-12T20:32:07.359477476Z","dependencies":[{"issue_id":"Rusticulum-c7u.3","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:42.237471525Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.4","title":"Implement Link keepalive interval calculation","description":"Implement keepalive interval calculation based on RTT:\n\nkeepalive_interval = max(min(rtt * 360/1.75, 360), 5)\n\nWhere:\n- rtt is the round-trip time in seconds\n- Minimum interval is 5 seconds\n- Maximum interval is 360 seconds (6 minutes)\n- Scale factor is 360/1.75 = ~205.7\n\npub fn keepalive_interval(rtt_seconds: f64) -\u003e f64;\n\nAlso implement stale link detection:\npub fn is_stale(last_activity: Duration, keepalive: Duration, factor: f64) -\u003e bool;\n\nimpl LinkActive {\n    pub fn keepalive_interval(\u0026self) -\u003e Duration;\n    pub fn should_send_keepalive(\u0026self, elapsed_since_last: Duration) -\u003e bool;\n    pub fn is_stale(\u0026self, elapsed_since_last: Duration) -\u003e bool;\n}\n\nTest against retry_timers.json:\n- Array of RTT values and expected keepalive intervals\n- Verify computed interval matches expected for each\n\nAdd tracing::debug! for keepalive calculations.\n\nProperty tests:\n- Interval is always \u003e= 5.0 seconds\n- Interval is always \u003c= 360.0 seconds\n- Higher RTT produces higher or equal interval\n- Zero RTT produces minimum interval (5 seconds)\n\nAcceptance: All retry_timers.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:50.595703394Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T20:32:07.388738717Z","closed_at":"2026-02-12T20:32:07.388741767Z","dependencies":[{"issue_id":"Rusticulum-c7u.4","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:50.596225936Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.4","depends_on_id":"Rusticulum-c7u.1","type":"blocks","created_at":"2026-02-08T03:33:52.514805608Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.5","title":"Implement Link encryption/decryption for active links","description":"Implement encrypt/decrypt operations on active links using the Token derived during handshake:\n\nimpl LinkActive {\n    pub fn encrypt(\u0026self, plaintext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, LinkError\u003e;\n    pub fn decrypt(\u0026self, ciphertext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, LinkError\u003e;\n    pub fn derived_key(\u0026self) -\u003e \u0026[u8; 64];  // for testing\n    pub fn mdu(\u0026self) -\u003e usize;  // effective max data unit for this link\n}\n\nThe Token instance is created from the 64-byte derived_key during handshake completion. All subsequent link traffic uses this Token for encryption/decryption.\n\nMDU calculation:\n  mdu = min(initiator_mdu, responder_mdu) - TOKEN_OVERHEAD\n  where TOKEN_OVERHEAD = 48 (16 IV + 32 HMAC)\n\nAdd tracing::trace! for encrypt/decrypt showing data lengths.\n\nProperty tests:\n- decrypt(encrypt(data)) == data for any data\n- Encrypted output is always longer than plaintext by exactly TOKEN_OVERHEAD + padding\n- Decrypt fails with wrong Token\n- Decrypt fails with corrupted ciphertext\n\nAcceptance: Encryption/decryption works with handshake-derived keys, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:59.059620408Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T20:56:15.809451772Z","closed_at":"2026-02-12T20:56:15.809451772Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.5","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:59.060269965Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.5","depends_on_id":"Rusticulum-c7u.2","type":"blocks","created_at":"2026-02-08T03:33:56.347174385Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.6","title":"Implement Channel envelope packing/unpacking","description":"Implement the 6-byte Channel envelope header:\n\npub struct Envelope {\n    pub msg_type: u16,\n    pub sequence: u16,\n    pub payload: Vec\u003cu8\u003e,\n}\n\nimpl Envelope {\n    pub const OVERHEAD: usize = 6;  // 2 + 2 + 2 bytes\n    \n    pub fn pack(\u0026self) -\u003e Vec\u003cu8\u003e;       // 6-byte header + payload\n    pub fn unpack(data: \u0026[u8]) -\u003e Result\u003cSelf, ChannelError\u003e;  // parse 6-byte header + payload\n}\n\nHeader format (all big-endian):\n  msg_type(2 bytes) + sequence(2 bytes) + length(2 bytes) + payload(length bytes)\n\nTest against channels.json -\u003e envelope_vectors:\n- Array of {msg_type (int), sequence (int), data (hex), packed_hex (hex)}\n- For each vector:\n  1. Pack msg_type + sequence + data, verify matches packed_hex\n  2. Unpack packed_hex, verify msg_type, sequence, and data match\n\nAdd tracing::trace! for envelope pack/unpack.\n\nProperty tests:\n- Round-trip: unpack(pack(envelope)) preserves all fields\n- Pack output length == 6 + payload.len()\n- Unpack rejects data shorter than 6 bytes\n- msg_type and sequence preserve full u16 range\n\nAcceptance: All channels.json envelope vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:09.19325114Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T21:01:25.275397707Z","closed_at":"2026-02-12T21:01:25.275397707Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.6","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:09.193779352Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.7","title":"Implement Channel sequencing and window control","description":"Implement sequence tracking and window-based flow control for channels:\n\npub struct ChannelState {\n    next_sequence: u16,       // Next sequence number to use (wraps at 0xFFFF)\n    expected_sequence: u16,   // Next expected incoming sequence\n    window_size: usize,       // Current window size\n    max_window: usize,        // Maximum window size\n    min_window: usize,        // Minimum window size\n}\n\nimpl ChannelState {\n    pub fn new() -\u003e Self;\n    pub fn next_sequence(\u0026mut self) -\u003e u16;  // Returns current, increments (wraps at 0xFFFF → 0)\n    pub fn is_in_window(\u0026self, sequence: u16) -\u003e bool;\n    pub fn acknowledge(\u0026mut self, sequence: u16);\n    pub fn window_adapt_success(\u0026mut self);    // Increase window\n    pub fn window_adapt_timeout(\u0026mut self);    // Decrease window\n}\n\nSequence wrapping: when sequence reaches 0xFFFF, it wraps to 0x0000.\n\nTest against channels.json:\n- Sequence wrapping behavior\n- Window adaptation under various conditions\n- window_thresholds data\n\nAdd tracing::debug! for sequence tracking and window changes.\n\nProperty tests:\n- Sequence always wraps correctly at 0xFFFF\n- Window size stays within min..=max bounds\n- Successive next_sequence calls produce incrementing values (with wrap)\n\nAcceptance: All channels.json sequencing/window vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:18.656123549Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T21:09:10.658097301Z","closed_at":"2026-02-12T21:09:10.658097301Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.7","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:18.656677241Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.7","depends_on_id":"Rusticulum-c7u.6","type":"blocks","created_at":"2026-02-08T03:34:00.711753213Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.8","title":"Implement Resource window adaptation","description":"Implement the adaptive window for resource transfers:\n\npub struct WindowState {\n    pub current: usize,       // starts at WINDOW_INITIAL (4)\n    pub min: usize,           // WINDOW_MIN (2)\n    pub max: usize,           // changes with speed class\n    pub flexibility: usize,   // WINDOW_FLEXIBILITY (4)\n}\n\nimpl WindowState {\n    pub fn new() -\u003e Self;\n    pub fn on_success(\u0026mut self);       // current = min(current + 1, max)\n    pub fn on_timeout(\u0026mut self);       // current = max(current - 1, min)\n    pub fn set_speed_class(\u0026mut self, bytes_per_sec: f64);\n}\n\nSpeed class thresholds:\n- \u003c 250 B/s: max = 4\n- \u003c 6250 B/s: max = 10\n- \u003e= 6250 B/s: max = 75\n\nConstants:\n  WINDOW_INITIAL = 4\n  WINDOW_MIN = 2\n  WINDOW_FLEXIBILITY = 4\n\nTest against window_adaptation.json:\n- Window growth sequences under various speed classes\n- Window shrink on timeout\n- Speed class transitions\n\nAdd tracing::debug! for window changes, trace! for individual adaptations.\n\nProperty tests:\n- current is always \u003e= min and \u003c= max\n- on_success never exceeds max\n- on_timeout never goes below min\n- Speed class changes update max correctly\n- If current \u003e new max after speed class change, current is clamped\n\nAcceptance: All window_adaptation.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:27.622415703Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T21:20:46.677356323Z","closed_at":"2026-02-12T21:20:46.677356323Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.8","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:27.622967656Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.9","title":"Implement Resource advertisement (msgpack)","description":"Implement resource advertisement construction and parsing using msgpack:\n\nResource advertisements use single-character keys for wire compatibility (Part 8 point 8):\n  t = transfer type\n  d = data/content hash\n  n = name/filename\n  h = total hash\n  r = random hash\n  o = original size (uncompressed)\n  i = segment index\n  l = total segments\n  q = request id / hash\n  f = flags\n  m = compressed size\n\npub struct ResourceAdvertisement {\n    pub transfer_type: u8,\n    pub data_hash: Vec\u003cu8\u003e,\n    pub name: Option\u003cString\u003e,\n    pub total_hash: Vec\u003cu8\u003e,\n    pub random_hash: Vec\u003cu8\u003e,\n    pub original_size: u64,\n    pub segment_index: Option\u003cu32\u003e,\n    pub total_segments: Option\u003cu32\u003e,\n    pub request_id: Option\u003cVec\u003cu8\u003e\u003e,\n    pub flags: u8,\n    pub compressed_size: Option\u003cu64\u003e,\n}\n\nimpl ResourceAdvertisement {\n    pub fn to_msgpack(\u0026self) -\u003e Vec\u003cu8\u003e;  // Serialize to msgpack dict with single-char keys\n    pub fn from_msgpack(data: \u0026[u8]) -\u003e Result\u003cSelf, ResourceError\u003e;\n}\n\nUse rmpv crate for precise control over msgpack encoding.\n\nTest against resources.json -\u003e advertisement_vectors:\n- Array of {msgpack_dict (showing field mapping), packed (hex)}\n- Serialize advertisement, verify matches packed hex\n- Deserialize packed hex, verify all fields match\n\nAdd tracing::debug! for advertisement creation/parsing.\n\nProperty tests:\n- Round-trip: from_msgpack(to_msgpack(adv)) preserves all fields\n- Serialized output uses single-character keys\n- Required fields are always present\n\nAcceptance: All resources.json advertisement vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:38.561614867Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T23:33:51.196578471Z","closed_at":"2026-02-12T23:33:51.196578471Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.9","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:38.562209182Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-e8i","title":"Optimize frame accumulator to avoid per-frame allocation (reticulum-interfaces)","description":"type: task","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-12T23:01:53.162282932-05:00","updated_at":"2026-02-13T15:12:55.151879591Z","closed_at":"2026-02-13T15:12:55.151881241Z"}
{"id":"Rusticulum-eap","title":"Refactor Announce::from_payload to use cursor pattern (reticulum-core)","description":"type: task","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-12T23:01:53.161035806-05:00","updated_at":"2026-02-13T15:12:55.039402083Z","closed_at":"2026-02-13T15:12:55.039404473Z"}
{"id":"Rusticulum-f32","title":"Extract shared cancellation token pattern (reticulum-interfaces)","description":"type: task","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-12T23:01:53.165928648-05:00","updated_at":"2026-02-13T15:12:55.168376091Z","closed_at":"2026-02-13T15:12:55.168377771Z"}
{"id":"Rusticulum-gxw","title":"Replace panic in InterfaceMode::from_vector_str with Result (reticulum-transport)","description":"type: bug","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-02-12T23:01:53.159802779-05:00","updated_at":"2026-02-13T14:40:39.824409042Z","closed_at":"2026-02-13T14:40:39.824409042Z","close_reason":"Closed"}
{"id":"Rusticulum-hxa","title":"Replace serde_json::Value with structured types in test vectors (reticulum-test-vectors)","description":"type: task","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-12T23:01:53.167092362-05:00","updated_at":"2026-02-13T16:22:29.732654054Z","closed_at":"2026-02-13T16:22:29.732654054Z","close_reason":"Closed"}
{"id":"Rusticulum-k37","title":"Add missing bounds check in ifac_verify (reticulum-transport)","description":"type: bug","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-12T23:01:53.151752489-05:00","updated_at":"2026-02-13T14:31:18.276237524Z","closed_at":"2026-02-13T14:31:18.276237524Z","close_reason":"Closed"}
{"id":"Rusticulum-lzv","title":"Fix blocking UnixStream::connect in async context (reticulum-interfaces)","description":"type: bug","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-12T23:01:53.15044515-05:00","updated_at":"2026-02-13T14:25:14.836130165Z","closed_at":"2026-02-13T14:25:14.836130165Z","close_reason":"Closed"}
{"id":"Rusticulum-n7x","title":"Testing Gaps and Edge Case Coverage","description":"Systematic testing gap analysis identified significant coverage holes across all 6 crates (980 existing tests). This epic tracks closing those gaps, organized by priority.\n\n## Current State\n- 980 tests all passing across 7 crates\n- 8 Docker interop scripts covering happy-path scenarios\n- Strong test vector coverage for crypto/wire formats\n- Weak coverage: interfaces lifecycle, node concurrency, timeout paths, adversarial inputs\n\n## Priority Tiers\n1. **HIGH** — Malformed input, concurrency races, timeout paths, interface lifecycle, boundary conditions\n2. **MEDIUM** — Property-based testing, cross-crate integration, negative/failure tests\n3. **LOW** — Coverage tooling, deterministic time, test helpers crate\n\n## Per-Crate Summary\n| Crate | Tests | Biggest Gap |\n|-------|------:|------------|\n| crypto | 32 | No proptest, no adversarial input |\n| core | ~47 | Truncated packets, empty payloads |\n| protocol | ~160 | State machine transitions, wraparound |\n| transport | 91 | IFAC boundaries, dedup stress |\n| interfaces | ~58 | No integration tests, auto lifecycle untested |\n| node | ~340 | Lifecycle races, storage corruption, timeouts |","status":"open","priority":1,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-14T12:34:04.002511873Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T12:34:04.002511873Z"}
{"id":"Rusticulum-n7x.1","title":"Malformed and adversarial input tests","description":"Add tests for malformed, truncated, and adversarial inputs across parsing boundaries. These are security-critical as the node starts handling real network traffic.\n\n## Wire Format (reticulum-core)\n- Truncated packets at every cut point from 1..500 bytes (currently only min-size rejection)\n- Zero-length payloads through RawPacket::parse, announce pipeline, resource pipeline\n- Oversized payloads (\u003e MTU) through every layer\n- Invalid bit patterns in PacketFlags (reserved bits set)\n- ContextType gap: systematically test all 235 invalid byte values (15-249), not just 5\n\n## Announce (reticulum-core)\n- Corrupted signature (1-bit flip) — should fail validation\n- Invalid Ed25519 public keys (all-zero, non-curve points)\n- Wrong destination_hash but otherwise valid announce\n- Very large app_data (\u003e10KB)\n- App data that mimics internal structure bytes\n\n## Crypto (reticulum-crypto)\n- Token decrypt with minimum valid size (48 bytes), undersized (47 bytes)\n- Token decrypt with corrupted HMAC at positions [0], [15], [31]\n- Token decrypt with corrupted IV (should cause padding error, not HMAC error)\n- AES-CBC decrypt with all-zero key/IV\n- HKDF with counter wraparound (output length = 8192 bytes, 256 blocks)\n- Ed25519 verify with wrong public key (cross-identity)\n\n## IFAC (reticulum-transport)\n- Boundary XOR masking with all-zero and all-0xFF at positions 0, 1, 2..2+ifac_size\n- IFAC sizes 1, 32, 64, 128 (currently only 8 and 16)\n- Unusual netnames: very long (\u003e1000 bytes), null bytes, empty string\n\n## Resource Protocol (reticulum-protocol)\n- Metadata decode with invalid msgpack (truncated, wrong types)\n- Metadata at 16MB boundary (0xFFFFFF size prefix)\n- Resource hash collision detection (adversarial hashmap)\n\nAcceptance: All new tests pass. No panics on any malformed input — only clean errors.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:34:22.865123504Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T13:03:22.716141902Z","closed_at":"2026-02-14T13:03:22.716141902Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-n7x.1","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:34:22.866040921Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.10","title":"Performance tests and benchmarking infrastructure","description":"Add performance benchmarks and stress tests to establish baselines and catch regressions as the codebase grows. Currently there are zero benchmarks anywhere in the project.\n\n## Benchmark Infrastructure\n- Set up `criterion` (or `divan`) benchmarks in each crate\n- Add `[[bench]]` targets to Cargo.toml for each crate that has hot paths\n- Create a CI job that runs benchmarks on PRs and reports regressions (optional, can use criterion's --save-baseline)\n- Establish baseline numbers for current performance on reference hardware\n\n## Crypto Benchmarks (reticulum-crypto)\n- SHA-256 / SHA-512 throughput (bytes/sec) for 64B, 1KB, 64KB, 1MB inputs\n- HMAC-SHA256 throughput\n- HKDF derivation latency (single key, 64-byte output)\n- AES-256-CBC encrypt/decrypt throughput for 64B, 1KB, 64KB payloads\n- Token encrypt/decrypt latency (includes HMAC + AES)\n- X25519 key generation + DH exchange latency\n- Ed25519 sign + verify latency\n- Compare against Python reference `time` measurements if available\n\n## Wire Format Benchmarks (reticulum-core)\n- RawPacket::parse throughput (packets/sec for HEADER_1 and HEADER_2)\n- RawPacket::serialize throughput\n- Announce::validate throughput (signature verification dominates)\n- HDLC frame/unframe throughput\n- KISS frame/unframe throughput\n- Identity encrypt/decrypt latency\n\n## Protocol State Machine Benchmarks (reticulum-protocol)\n- Link handshake full cycle latency (LINKREQUEST → active, in-memory only)\n- LinkActive encrypt/decrypt throughput\n- Channel envelope pack/unpack throughput\n- Resource prepare_resource latency for 1KB, 64KB, 1MB data (includes compress + encrypt + hashmap)\n- Resource assemble_resource latency for same sizes\n- ResourceHashmap from_data + segmentation for large part counts (2000+ parts)\n- StreamDataMessage compress_chunk latency and compression ratio\n\n## Transport Benchmarks (reticulum-transport)\n- PacketHashlist insert throughput (measuring rotation overhead)\n- PacketHashlist contains lookup latency at various fill levels (10K, 100K, 500K entries)\n- PathTable lookup latency with 100, 1000, 10000 entries\n- IFAC apply/verify throughput\n- PacketRouter full inbound processing pipeline (parse + dedup + classify + route)\n- AnnounceTable process_retransmissions with 100+ pending entries\n\n## Node Integration Benchmarks (reticulum-node)\n- Full packet processing latency: raw bytes in → routing decision out\n- Throughput: packets/sec through node event loop (loopback interface)\n- Link establishment end-to-end latency (in-process, no network)\n- Resource transfer throughput: bytes/sec for 1MB transfer over in-process link\n- Storage save/load latency for path table with 1000 entries\n- Storage save/load latency for hashlist with 100K entries\n\n## Stress Tests (separate from benchmarks)\n- Memory usage under load: 1000 path table entries + 500K hashlist + 100 active links\n- Sustained throughput: 10 minutes of continuous packet processing, verify no memory growth\n- Peak connections: how many simultaneous TCP clients before degradation\n- Announce burst handling: 1000 announces in 1 second, verify rate limiting and no OOM\n\n## Profiling Support\n- Document how to run `cargo flamegraph` on the node binary\n- Add `#[inline]` hints to hot paths identified by profiling (only after measurement, not speculatively)\n- Consider adding `tracing` spans to key operations for latency breakdown\n\nAcceptance: criterion benchmarks exist for at least crypto, wire format, and link encrypt/decrypt.\nBaseline numbers documented. CI can optionally run benchmarks.","status":"open","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:39:25.994233486Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T12:39:25.994233486Z","dependencies":[{"issue_id":"Rusticulum-n7x.10","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:39:25.994836101Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.2","title":"Concurrency and lifecycle race tests","description":"Add tests for concurrent operations and lifecycle race conditions in the node crate. These matter as the node handles multiple simultaneous connections.\n\n## Node Lifecycle (reticulum-node::node)\n- Double shutdown: shutdown() called twice (should be idempotent)\n- Shutdown during active link handshake (mid-LRPROOF, mid-LRRTT)\n- Shutdown during active resource transfer (parts in flight)\n- Shutdown during channel message delivery\n- Interface startup failure: one interface fails to bind, others should still start\n- Event channel overflow: burst of 1024+ packets faster than main loop processes\n- Receive bridge panic recovery: parse_packet panic should not crash node\n\n## Link Manager (reticulum-node::link_manager)\n- Two simultaneous LINKREQUEST packets to same responder destination\n- Second LINKREQUEST during active handshake (responder already has pending)\n- LRRTT arriving for wrong link_id\n- Max simultaneous links stress test (100+ active links)\n- Known identities memory: 1M identities accumulated without expiry\n- Stale pending_link_targets cleanup\n\n## Resource Manager (reticulum-node::resource_manager)\n- Multiple concurrent resource transfers on same link\n- Part retransmission: same part requested multiple times (idempotency)\n- Out-of-order part reception\n- 1000 concurrent resources on same link (resource exhaustion)\n\n## Storage (reticulum-node::storage)\n- Storage persist triggered during concurrent path table modification\n- Multiple tasks calling save_identity simultaneously\n- Partial write recovery: .tmp file exists from previous crash\n\n## Channel Manager (reticulum-node::channel_manager)\n- 1000 simultaneous streams on same link\n- Rapid on_delivery/on_timeout cycles (window adaptation stress)\n- Handler panic recovery (Rust panic in request handler)\n\nAcceptance: All tests pass. No deadlocks, panics, or data corruption under concurrent load.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:34:38.75674581Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T13:38:04.563140406Z","closed_at":"2026-02-14T13:38:04.563140406Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-n7x.2","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:34:38.757329994Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.3","title":"Timeout and recovery path tests","description":"Add tests for timeout handling and error recovery paths. Currently only happy paths are tested — real networks have failures.\n\n## Link Handshake Timeouts (reticulum-node::link_manager)\n- Initiator timeout: LINKREQUEST sent, no LRPROOF received within establishment_timeout\n- Responder timeout: LRPROOF sent, no LRRTT received\n- Stale link detection: active link exceeds STALE_TIME without traffic\n- Keepalive timeout: active link exceeds keepalive interval\n- Link teardown: all TeardownReason variants exercised\n\n## Resource Transfer Timeouts (reticulum-node::resource_manager)\n- Sender timeout: no part requests received after advertising\n- Receiver timeout: parts stop arriving mid-transfer\n- Cancellation mid-transfer: sender cancels, receiver handles gracefully\n- Proof mismatch: receiver computes different proof than sender expects\n\n## Request/Response Timeouts (reticulum-protocol::request)\n- compute_request_timeout exercised end-to-end (not just unit formula)\n- Request timeout with no response (client side)\n- Response arriving after timeout (late response handling)\n\n## Reconnection Recovery (reticulum-interfaces)\n- TCP client: rapid disconnect→reconnect cycles (10x in 1 second)\n- TCP client: reconnect during active frame transmission\n- TCP client: max reconnect attempts exhausted\n- Local client: socket disappears mid-connection\n- Local client: stale socket from crashed server\n\n## Storage Recovery (reticulum-node::storage)\n- Corrupt identity file: truncated bytes, wrong length\n- Corrupt path table: invalid postcard data, truncated file\n- Corrupt hashlist: invalid postcard data\n- Missing storage directory on startup (should create)\n- Startup with .tmp file from previous crash (should ignore/clean)\n\n## Note on Test Infrastructure\nSeveral of these tests require simulating time passage. Consider whether a clock abstraction\n(e.g., tokio::time::pause/advance) would make these tests deterministic rather than relying\non real wall-clock delays.\n\nAcceptance: All timeout and recovery paths return clean errors, no panics, no resource leaks.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:34:54.962196178Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T14:03:35.009434965Z","closed_at":"2026-02-14T14:03:35.009434965Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-n7x.3","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:34:54.962841895Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.4","title":"Interface layer test coverage","description":"The reticulum-interfaces crate has the weakest test coverage (58 tests, no integration test directory). Most tests only cover construction and basic roundtrip — lifecycle, error handling, and the auto interface are barely tested.\n\n## Auto Interface (3 tests → needs ~20+)\nCurrently only tests construction, multicast address derivation, and transmit-when-not-started.\nMissing the entire lifecycle:\n- start() → discover peers → transmit → receive → stop()\n- Multicast socket creation failures (permission denied, IPv6 disabled)\n- Peer discovery and management (add, refresh, prune)\n- Echo detection (receiving own discovery packet)\n- Invalid discovery token rejection\n- Multiple peers on same/different interfaces\n- Data transport to discovered peers (unicast)\n- Configuration variants: different group IDs, scopes, allowed/ignored interfaces\n\n## TCP Client (4 tests → needs ~10+)\n- Connection drops during transmit (write fails mid-frame)\n- Partial TCP reads (incomplete HDLC frame, then EOF)\n- Backpressure: rapid transmit calls exceeding mpsc channel capacity\n- Graceful shutdown under active I/O load\n- Max reconnect attempts exhausted\n\n## TCP Server (2 tests → needs ~8+)\n- Rapid concurrent client connections\n- Server continues accepting after individual client disconnection\n- Port already in use error handling\n- Pruning disconnected clients from active list\n- Large client count stress (100+ connections)\n\n## UDP (5 tests → needs ~8+)\n- MTU boundary: transmit exactly 1064 bytes\n- Oversized packet handling (\u003e MTU)\n- Zero-length datagram\n- Broadcast/multicast with multiple receivers\n- Port reuse on rapid restart (SO_REUSEADDR)\n\n## Local Client/Server (5 tests → needs ~10+)\n- Socket does not exist (ENOENT)\n- Permission denied (EACCES)\n- Socket path too long (UNIX_PATH_MAX)\n- Concurrent client connections to same server\n- Socket file cleanup verification\n\n## Framing Accumulator (11 tests → needs ~5 more)\n- Large frame at MTU boundary\n- All-escape-sequence payload (every byte is 0x7E or 0x7D)\n- Maximum accumulator buffer stress test\n- Escape sequence at exact frame boundary\n\n## Shutdown Token (9 tests — good coverage, minor gaps)\n- Task never completes (join_all with timeout)\n- Concurrent signal_stop calls\n\n## Integration Test Directory\nCreate crates/reticulum-interfaces/tests/ with:\n- Multi-interface scenario: TCP server + 2 UDP → packet flooding between them\n- Interface trait conformance harness that any Interface impl must pass\n\nAcceptance: Interface crate test count doubles from ~58 to ~120+. Auto interface has lifecycle tests.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:35:16.8696367Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T14:22:29.085673146Z","closed_at":"2026-02-14T14:22:29.085673146Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-n7x.4","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:35:16.870231934Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.5","title":"Boundary condition and wraparound tests","description":"Add tests for numeric boundaries, wraparound, and off-by-one conditions that accumulate into real bugs as protocol complexity grows.\n\n## Sequence/ID Wraparound (reticulum-protocol)\n- Channel sequence wraparound: exhaustive test at SEQ_MODULUS (65536) boundary\n  - Current: only 6 cases tested of 2^16 range\n  - Need: window validation during exact overflow (65534→65535→0→1)\n  - Need: TX and RX sequence interaction during wraparound\n- Stream ID rollover at STREAM_ID_MAX (0x3FFF = 16383)\n- Resource window state at boundary: outstanding == window exactly\n\n## Packet Size Boundaries (reticulum-core, reticulum-transport)\n- RawPacket::parse with exactly HEADER_1_SIZE (19) bytes — zero payload, should succeed\n- RawPacket::parse with exactly HEADER_2_SIZE (35) bytes — zero payload, should succeed\n- Packet at exactly MTU (500 bytes) through full pipeline\n- Transport header inject on packet at MTU-16 (should succeed) and MTU (should fail/truncate?)\n- Hop count at 0 and 255 through inject/strip roundtrip\n\n## Expiration Boundaries (reticulum-transport)\n- Path table: now == timestamp + ttl (not expired, strict \u003e), now == timestamp + ttl + 1 (expired)\n  - Currently tested in path_decision but not in table query methods\n- Reverse table: now == timestamp + REVERSE_TIMEOUT (480s) boundary\n- Link table: now == proof_timeout boundary\n- Dedup hashlist: exactly at rotation threshold (500,000 vs 500,001)\n\n## Protocol Field Boundaries (reticulum-protocol)\n- Envelope with zero-length payload (6-byte header only)\n- Envelope with max payload (0xFFFF bytes)\n- Channel MDU when outlet_mdu \u003c ENVELOPE_OVERHEAD (6) — underflow protection\n- Resource metadata at 3-byte size prefix limit (0xFFFFFF = 16MB)\n- PKCS7 pad with block_size = 255 (max valid), data requiring 254 bytes padding\n- HKDF output at exactly 32 bytes (1 block) and 33 bytes (2 blocks, truncated)\n- Token at minimum size (48 bytes: 16 IV + 0 ciphertext + 32 HMAC)\n\n## Hop Count (reticulum-transport, reticulum-node)\n- Packet with hops = PATHFINDER_M (128) — should be dropped\n- Packet with hops = PATHFINDER_M - 1 (127) — should be forwarded\n- Announce with hops = 0 through path table processing\n- Inject transport header with hops = 255 — max value\n\n## Empty Data Paths\n- Zero-length data through: RawPacket, announce, resource, channel, buffer stream\n- Empty TOML config sections (valid but no interfaces)\n- Empty path table save/load\n- Empty hashlist save/load\n\nAcceptance: All boundary tests pass. No panics, overflows, or underflows at any boundary.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:35:41.176165087Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T13:14:32.154477223Z","closed_at":"2026-02-14T13:14:32.154477223Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-n7x.5","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:35:41.176793092Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.6","title":"Property-based roundtrip tests with proptest","description":"Add property-based tests using the existing proptest dependency to catch classes of bugs that point tests miss. proptest is already in workspace deps but underused.\n\n## Roundtrip Invariants (highest value)\nThese catch serialization asymmetry, escape bugs, and transformation errors:\n\n- `parse(serialize(packet)) == packet` for any valid RawPacket (reticulum-core)\n- `encrypt(key, iv, decrypt(key, iv, ct)) == ct` for any valid ciphertext (reticulum-crypto)\n- `Token::decrypt(key, Token::encrypt(key, pt)) == pt` for any plaintext (reticulum-crypto)\n- `hdlc_unframe(hdlc_frame(data)) == data` for any byte sequence (reticulum-core)\n- `kiss_unframe(kiss_frame(data)) == data` for any byte sequence (reticulum-core)\n- `ifac_verify(config, ifac_apply(config, raw)) == raw` for any raw packet (reticulum-transport)\n- `strip_header(inject_header(pkt, tid), hops) roundtrips` modulo hops (reticulum-transport)\n- `pkcs7_unpad(pkcs7_pad(data, bs), bs) == data` for any data and block_size 1..=255\n- `from_bytes(to_bytes(hashmap)) == hashmap` for ResourceHashmap (reticulum-protocol)\n- `Envelope::unpack(Envelope::pack(env)) == env` for any Envelope (reticulum-protocol)\n\n## Cryptographic Properties\n- Ed25519: sign then verify always succeeds; sign then verify-with-wrong-key always fails\n- X25519: DH symmetry — a.dh(B) == b.dh(A) for any key pairs\n- HMAC: verify(key, data, hmac(key, data)) always succeeds\n- HMAC: 1-bit flip in key or data always changes MAC\n- AES-CBC: ciphertext length always multiple of 16, always \u003e= plaintext + 1\n\n## State Machine Properties\n- Channel window always in [window_min, window_max] after any on_delivery/on_timeout sequence\n- Resource window always in [window_min, window_max] after any adaptation\n- Path table: if not expired at time T, not expired at any T' \u003c T\n- Dedup: if insert() returned true, contains() returns true (until rotation)\n- Announce: decide_retransmission is deterministic for same inputs\n\n## Type System Properties\n- All newtype TryFrom: `Type::try_from(val.as_ref()) == Ok(val)` for any valid instance\n- All Display: output is always non-empty, valid UTF-8, exactly N*2 hex chars for hash types\n- PathHash/RequestId: from_path deterministic, always 16 bytes\n\nAcceptance: At least 15 proptest properties added across crypto/core/protocol/transport. Each runs 256+ cases.","status":"open","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:36:00.558422313Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T12:36:00.558422313Z","dependencies":[{"issue_id":"Rusticulum-n7x.6","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:36:00.559039958Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.7","title":"Cross-crate integration test scenarios","description":"Add Docker interop test scenarios that go beyond the current happy-path coverage. The existing 8 Docker scripts test basic bidirectional flows but miss failure modes, stress, and complex topologies.\n\n## Multi-Hop Data Transfer\n- Resource transfer over multi-hop path (Rust→Python→Rust relay)\n  - Current: only announces and links tested over multi-hop\n  - Need: actual data (resource or channel) flowing through relay\n- Channel message over multi-hop relay path\n\n## Authentication (IFAC)\n- Configure network_name/network_key on both Rust and Python nodes\n- Verify IFAC-protected packets are accepted by authenticated peer\n- Verify IFAC-protected packets are rejected by unauthenticated peer\n- Test with mismatched network keys (should reject)\n\n## Failure Modes\n- Duplicate packet detection: send same packet twice, verify second dropped\n- Hop limit enforcement: packet with hops near limit, verify drop at threshold\n- Link teardown during transfer: kill one side mid-resource-transfer, verify other side cleans up\n- Storage recovery: kill Rust node, restart, verify identity/path table reloaded from disk\n\n## Stress Scenarios\n- Concurrent links: 5+ simultaneous link handshakes on one node\n- Announce storm: 20+ announces in rapid succession, verify rate limiting\n- Large resource: 1MB+ resource transfer (tests segmentation at scale)\n- Buffer stream with incompressible data (should skip compression gracefully)\n\n## Transport Node Behavior\n- Transport node does NOT flood announces as HEADER_1 (only retransmits with HEADER_2)\n- Verify announce retransmission timing matches PATHFINDER_G + PATHFINDER_RW formula\n- Mixed topology: 4+ nodes with different transport/non-transport configurations\n\n## Relation to Rusticulum-3a5.7\nThis task covers specific scenarios identified by gap analysis. Rusticulum-3a5.7 covers the\nbroader compatibility test suite framework. These can be merged if appropriate.\n\nAcceptance: At least 5 new Docker test scripts covering the above scenarios. All pass.","status":"open","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:36:17.804174422Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T12:36:17.804174422Z","dependencies":[{"issue_id":"Rusticulum-n7x.7","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:36:17.804834018Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.8","title":"Negative and failure path tests","description":"Add tests that verify correct behavior when things go wrong. Currently most tests only exercise success paths.\n\n## Cross-Identity Failures (reticulum-crypto, reticulum-core)\n- Sign with identity A, verify with identity B — must fail\n- Encrypt to identity A, decrypt with identity B — must fail\n- ECDH with mismatched keys produces different shared secrets\n\n## Link Protocol Failures (reticulum-protocol, reticulum-node)\n- LRPROOF with wrong link_id — must reject\n- LRPROOF with invalid signature (1-bit flip) — must reject\n- Link data decryption with wrong derived key — must fail\n- LRRTT decrypted with wrong key — garbage RTT, must handle gracefully\n- Handshake from unknown destination — already tested, but verify error type\n\n## Resource Protocol Failures (reticulum-protocol, reticulum-node)\n- Proof mismatch: receiver computes different proof than sender expects\n- Missing parts: receiver claims completion without all parts (should fail assembly)\n- Corrupt part: part data doesn't match hashmap entry (hash mismatch)\n- Unknown resource hash in part request — already tested\n\n## Channel/Request Failures (reticulum-protocol, reticulum-node)\n- Response for non-existent request ID\n- Multiple responses to same request (second should be ignored)\n- Request to unregistered path (no handler)\n- Channel data with unknown msg_type — already tested, verify graceful handling\n\n## Config Failures (reticulum-node::config)\n- Malformed TOML syntax\n- Missing required fields (e.g., tcp_client without target)\n- Invalid socket address (bad port, malformed IP)\n- Invalid interface mode string\n- Duplicate interface names\n\n## Error Type Coverage (all crates)\n- Verify Display impl for every error variant in: CryptoError, PacketError, IdentityError,\n  FramingError, AnnounceError, LinkError, ChannelError, ResourceError, BufferError,\n  RequestError, RouterError, PathError, IfacError, NodeError, StorageError\n- Verify all error variants are constructible and have meaningful messages\n- Verify From trait conversions produce correct target variants\n\nAcceptance: All failure paths return specific error types (not panics). Error Display messages tested.","status":"open","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:36:34.275420246Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T12:36:34.275420246Z","dependencies":[{"issue_id":"Rusticulum-n7x.8","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:36:34.276040762Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-n7x.9","title":"Test infrastructure: coverage tooling, deterministic time, test helpers","description":"Infrastructure improvements that make tests more reliable and coverage measurable.\n\n## Coverage Tooling\n- Set up cargo-tarpaulin (or cargo-llvm-cov) for line/branch coverage measurement\n- Add coverage report to CI workflow\n- Establish baseline: measure current coverage per crate\n- Target: \u003e80% in critical modules (link_manager, resource_manager, node), 100% in pure functions\n\n## Deterministic Time Abstraction\nSeveral modules use Instant::now() or SystemTime::now() directly, making timeout tests\nflaky or requiring real wall-clock delays:\n- reticulum-transport: path table expiration, announce retransmission, reverse table timeout\n- reticulum-node: maintenance tick, storage persist interval, link stale/timeout detection\n- reticulum-interfaces: peer prune timeout, reconnect delay\n\nOptions:\n1. tokio::time::pause() + advance() for async tests (simplest, already available)\n2. Clock trait injection (more testable but more invasive)\n3. Accept wall-clock delays in tests (current approach, works but slow)\n\nRecommendation: Use tokio::time::pause() for new timeout tests. Only introduce Clock trait\nif tokio pause proves insufficient.\n\n## Test Helpers Crate or Module\nCommon test patterns are duplicated across crates:\n- Building test packets (valid HEADER_1/HEADER_2 with specific flags/context)\n- Creating test identities (keypair generation + destination registration)\n- Setting up link pairs (full handshake → two active LinkActive instances)\n- Creating test IFAC configs\n- Hex encoding/decoding helpers\n\nOptions:\n1. Add `reticulum-test-helpers` crate (cleanest, but adds workspace complexity)\n2. Add `test_helpers` module to each crate's `#[cfg(test)]` (current approach, duplicated)\n3. Add shared helpers to `reticulum-test-vectors` crate (already exists, could extend)\n\nRecommendation: Extend reticulum-test-vectors with a `helpers` feature flag that provides\ncommon test utilities. Avoids new crate while reducing duplication.\n\n## Interface Trait Conformance Harness\nCreate a generic test function that any Interface implementation must pass:\n- Construction with valid config\n- start() transitions to connected state\n- transmit() before start() returns NotConnected\n- transmit() after start() succeeds\n- stop() transitions to disconnected state\n- transmit() after stop() returns NotConnected\n- Double start/stop is idempotent\n\nThis prevents regression when adding new interface types (Serial, I2P, etc.).\n\nAcceptance: Coverage tooling integrated. At least one timeout test uses deterministic time.\nTest helper duplication reduced by 50%+.","status":"open","priority":3,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-14T12:37:00.511952781Z","created_by":"Matthew Remmel","updated_at":"2026-02-14T12:37:00.511952781Z","dependencies":[{"issue_id":"Rusticulum-n7x.9","depends_on_id":"Rusticulum-n7x","type":"parent-child","created_at":"2026-02-14T12:37:00.512573646Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-njt","title":"Fix blocking I/O in async event loop (reticulum-node)","description":"type: bug","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-12T23:01:53.149019517-05:00","updated_at":"2026-02-13T14:25:14.853451423Z","closed_at":"2026-02-13T14:25:14.853451423Z","close_reason":"Closed"}
{"id":"Rusticulum-nrn","title":"Interfaces and Node (reticulum-interfaces, reticulum-node)","description":"Implement network interfaces (TCP with HDLC framing, UDP broadcast/unicast, Local IPC via Unix socket, Auto IPv6 multicast discovery) and the node orchestrator (config parsing, interface startup, router wiring, storage). All interfaces are async. The Interface trait defines async transmit/receive, bitrate, and mode. Depends on reticulum-transport.","status":"closed","priority":1,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:57.603391869Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:51:32.154883621-05:00","closed_at":"2026-02-12T22:51:32.154883621-05:00","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-nrn","depends_on_id":"Rusticulum-uqj","type":"blocks","created_at":"2026-02-08T03:15:08.676336542Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.1","title":"Define Interface trait with async transmit/receive","description":"Define the async Interface trait that all network interfaces implement:\n\n#[async_trait]\npub trait Interface: Send + Sync {\n    fn name(\u0026self) -\u003e \u0026str;\n    fn bitrate(\u0026self) -\u003e u64;  // bits per second\n    fn mtu(\u0026self) -\u003e usize;    // Maximum transmission unit (default 500)\n    fn mode(\u0026self) -\u003e InterfaceMode;\n    fn is_connected(\u0026self) -\u003e bool;\n    \n    async fn transmit(\u0026self, data: \u0026[u8]) -\u003e Result\u003c(), InterfaceError\u003e;\n    async fn receive(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, InterfaceError\u003e;\n    \n    async fn start(\u0026mut self) -\u003e Result\u003c(), InterfaceError\u003e;\n    async fn stop(\u0026mut self) -\u003e Result\u003c(), InterfaceError\u003e;\n}\n\npub enum InterfaceMode {\n    Full,           // Can both send and receive\n    AccessPoint,    // Stationary, higher path TTL\n    Roaming,        // Mobile, shorter path TTL\n    Boundary,       // Gateway between networks\n}\n\npub type InterfaceId = u64;  // Unique interface identifier\n\nAlso define callback/event types:\npub enum InterfaceEvent {\n    PacketReceived { data: Vec\u003cu8\u003e, interface_id: InterfaceId },\n    Connected,\n    Disconnected,\n    Error(InterfaceError),\n}\n\nAdd tracing::info! for interface lifecycle (start/stop/connect/disconnect), debug! for transmit/receive.\n\nAcceptance: Trait compiles, can be implemented by concrete types, async-compatible with tokio.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:39.056091401Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:15:59.083523045-05:00","closed_at":"2026-02-12T21:00:53.710092-05:00","dependencies":[{"issue_id":"Rusticulum-nrn.1","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:39.056726137Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.2","title":"Implement TCP interface with HDLC framing","description":"Implement a TCP network interface using HDLC framing from reticulum-core:\n\npub struct TcpInterface {\n    name: String,\n    address: SocketAddr,\n    bitrate: u64,\n    mode: InterfaceMode,\n    stream: Option\u003cTcpStream\u003e,\n}\n\nThe TCP interface:\n- Connects to a remote TCP endpoint (client mode) or listens for connections (server mode)\n- Frames all outgoing packets with HDLC (hdlc_frame from core crate)\n- Unframes all incoming data with HDLC (hdlc_unframe from core crate)\n- Handles connection lifecycle (connect, reconnect on failure)\n- Supports both client and server modes\n\nServer mode: listen on address, accept connections\nClient mode: connect to address, reconnect on disconnect\n\nUse tokio for async I/O:\n- tokio::net::TcpStream for connections\n- tokio::net::TcpListener for server mode\n- Read loop with buffered reader, detecting HDLC frame boundaries\n\nAdd tracing::info! for connection events, debug! for packet send/receive with sizes, error! for connection failures.\n\nEdge cases:\n- Partial HDLC frames (data split across TCP segments)\n- Connection drops mid-frame\n- Multiple frames in single TCP read\n- Empty frames\n- Very large frames (near MTU)\n\nAcceptance: TCP interface can send/receive HDLC-framed packets over TCP, handles connection lifecycle.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:43.057153011Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:15:59.08482343-05:00","closed_at":"2026-02-12T21:18:07.471724-05:00","dependencies":[{"issue_id":"Rusticulum-nrn.2","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:43.057827588Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.2","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:16.588243656Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.3","title":"Implement UDP interface","description":"Implement a UDP network interface:\n\npub struct UdpInterface {\n    name: String,\n    bind_address: SocketAddr,\n    target_address: Option\u003cSocketAddr\u003e,  // None for broadcast\n    bitrate: u64,\n    mode: InterfaceMode,\n    socket: Option\u003cUdpSocket\u003e,\n}\n\nThe UDP interface:\n- Binds to a local UDP port\n- Supports unicast (specific target) and broadcast modes\n- Each UDP datagram contains exactly one packet (no framing needed)\n- No connection state to manage\n\nUse tokio::net::UdpSocket for async I/O.\n\nBroadcast mode:\n- Set SO_BROADCAST socket option\n- Send to broadcast address\n- Receive from any source\n\nAdd tracing::info! for interface startup, debug! for packet send/receive.\n\nAcceptance: UDP interface can send/receive raw packets over UDP unicast and broadcast.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:45.157954473Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:15:59.08565099-05:00","closed_at":"2026-02-12T21:36:57.285948-05:00","dependencies":[{"issue_id":"Rusticulum-nrn.3","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:45.158503496Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.3","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:17.314344604Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.4","title":"Implement Local interface (Unix IPC)","description":"Implement a Local interface for inter-process communication:\n\npub struct LocalInterface {\n    name: String,\n    socket_path: PathBuf,\n    bitrate: u64,\n    mode: InterfaceMode,\n}\n\nThe Local interface:\n- Uses Unix domain sockets for IPC between Reticulum instances on the same machine\n- Server mode: creates and listens on a Unix socket\n- Client mode: connects to existing Unix socket\n- Uses HDLC framing (same as TCP) for message boundaries\n- Handles socket cleanup on shutdown\n\nUse tokio::net::UnixListener and UnixStream.\n\nAdd tracing::info! for IPC connection events, debug! for message details.\n\nAcceptance: Local interface enables IPC between processes on the same machine.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:47.453282981Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:15:59.086415877-05:00","closed_at":"2026-02-12T21:56:22.664141-05:00","dependencies":[{"issue_id":"Rusticulum-nrn.4","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:47.453815743Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.4","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:18.227021311Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.5","title":"Implement Auto interface (IPv6 multicast discovery)","description":"Implement the Auto interface for automatic peer discovery:\n\npub struct AutoInterface {\n    name: String,\n    group_address: Ipv6Addr,  // Multicast group\n    port: u16,\n    discovery_port: u16,\n    bitrate: u64,\n    mode: InterfaceMode,\n    peers: HashMap\u003cSocketAddr, PeerInfo\u003e,\n}\n\nThe Auto interface:\n- Joins an IPv6 multicast group for peer discovery\n- Periodically broadcasts discovery messages\n- Maintains a list of discovered peers\n- Establishes direct TCP/UDP connections to discovered peers\n- Falls back to multicast for initial discovery\n\nDiscovery protocol:\n- Multicast announce with interface identity\n- Peers respond with their connection details\n- Direct connections established after discovery\n\nAdd tracing::info! for peer discovery/loss, debug! for discovery protocol details.\n\nAcceptance: Auto interface discovers peers via IPv6 multicast and establishes connections.","status":"closed","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:50.109552632Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:15:59.087173673-05:00","closed_at":"2026-02-12T22:14:48.694405-05:00","dependencies":[{"issue_id":"Rusticulum-nrn.5","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:50.110180198Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.5","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:18.892095589Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.5","depends_on_id":"Rusticulum-nrn.3","type":"blocks","created_at":"2026-02-08T03:38:19.65116503Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.6","title":"Implement Node orchestrator","description":"Implement the Node struct that ties everything together:\n\npub struct Node {\n    identity: Identity,\n    router: Router,\n    interfaces: Vec\u003cBox\u003cdyn Interface\u003e\u003e,\n    config: NodeConfig,\n    // Internal channels for async coordination\n}\n\npub struct NodeConfig {\n    pub identity_path: Option\u003cPathBuf\u003e,\n    pub interfaces: Vec\u003cInterfaceConfig\u003e,\n    pub enable_transport: bool,\n    pub storage_path: PathBuf,\n}\n\npub enum InterfaceConfig {\n    Tcp { name: String, address: SocketAddr, mode: InterfaceMode },\n    Udp { name: String, bind: SocketAddr, target: Option\u003cSocketAddr\u003e, mode: InterfaceMode },\n    Local { name: String, path: PathBuf },\n    Auto { name: String, group: Ipv6Addr, port: u16 },\n}\n\nimpl Node {\n    pub async fn new(config: NodeConfig) -\u003e Result\u003cSelf, NodeError\u003e;\n    pub async fn start(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e;\n    pub async fn stop(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e;\n    pub fn register_destination(\u0026mut self, destination: Destination);\n    pub fn identity(\u0026self) -\u003e \u0026Identity;\n}\n\nThe Node:\n- Loads or generates identity on startup\n- Creates and starts all configured interfaces\n- Wires interfaces to the router\n- Spawns async tasks for:\n  - Receiving packets from each interface\n  - Processing packets through the router\n  - Sending outgoing packets to appropriate interfaces\n  - Periodic maintenance (path expiration, keepalives, announce propagation)\n- Handles graceful shutdown\n\nConfig parsing: support reading from a TOML or similar config file (matching Python reference format where practical).\n\nAdd tracing::info! for node lifecycle events, debug! for configuration details, error! for startup failures.\n\nAcceptance: Node can start with configured interfaces, route packets between them, and shut down cleanly.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:54.326500682Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:35:42.842272731-05:00","closed_at":"2026-02-12T22:35:42.842272731-05:00","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-nrn.6","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:54.327034224Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.6","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:20.108951603Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.7","title":"Implement identity persistence and storage","description":"Implement identity and state persistence:\n\npub struct Storage {\n    base_path: PathBuf,\n}\n\nimpl Storage {\n    pub fn new(path: PathBuf) -\u003e Result\u003cSelf, StorageError\u003e;\n    \n    // Identity persistence\n    pub fn load_identity(\u0026self) -\u003e Result\u003cOption\u003cIdentity\u003e, StorageError\u003e;\n    pub fn save_identity(\u0026self, identity: \u0026Identity) -\u003e Result\u003c(), StorageError\u003e;\n    \n    // Known destinations (for path caching across restarts)\n    pub fn load_known_destinations(\u0026self) -\u003e Result\u003cVec\u003c(DestinationHash, IdentityHash)\u003e, StorageError\u003e;\n    pub fn save_known_destination(\u0026self, dest: \u0026DestinationHash, identity: \u0026IdentityHash) -\u003e Result\u003c(), StorageError\u003e;\n    \n    // Path table persistence\n    pub fn load_path_table(\u0026self) -\u003e Result\u003cPathTable, StorageError\u003e;\n    pub fn save_path_table(\u0026self, table: \u0026PathTable) -\u003e Result\u003c(), StorageError\u003e;\n}\n\nFile format should be simple and robust:\n- Identity: raw 64-byte private key file\n- Known destinations: one entry per line, hex-encoded\n- Path table: serialized with serde (JSON or bincode)\n\nAdd tracing::info! for storage operations, warn! for missing/corrupt files.\n\nAcceptance: Identity persists across restarts, known destinations are cached.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:57.612675634Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T22:48:59.945219732-05:00","closed_at":"2026-02-12T22:48:59.945219732-05:00","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-nrn.7","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:57.613227627Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nx1","title":"Replace catch-all _ in exhaustive matches (reticulum-transport)","description":"type: task","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-12T23:01:53.164769025-05:00","updated_at":"2026-02-13T15:12:55.135263715Z","closed_at":"2026-02-13T15:12:55.135265275Z"}
{"id":"Rusticulum-sed","title":"Crypto Primitives (reticulum-crypto)","description":"Implement all cryptographic primitives in dependency order: SHA-256/SHA-512, HMAC-SHA256, HKDF-SHA256 (RFC 5869), PKCS7 padding, AES-256-CBC, Token (modified Fernet), X25519 ECDH, Ed25519 signatures. Every primitive must pass against the JSON test vectors. This crate is pure crypto with no protocol concepts, no async, no I/O, and should support optional no_std. Uses RustCrypto family crates (sha2, hmac, aes, cbc, x25519-dalek, ed25519-dalek).","status":"closed","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:42.286647358Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.710294599Z","closed_at":"2026-02-12T19:12:31.710294599Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed","depends_on_id":"Rusticulum-97m","type":"blocks","created_at":"2026-02-08T03:15:08.599369862Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.1","title":"Implement SHA-256 and SHA-512 hash wrappers","description":"Implement thin wrappers around the sha2 crate providing:\n\nfn sha256(data: \u0026[u8]) -\u003e [u8; 32]\nfn sha512(data: \u0026[u8]) -\u003e [u8; 64]\n\nAlso provide incremental/streaming hash support via a wrapper type.\n\nTest against hashes.json which contains:\n- sha256_vectors: array of {input (hex), expected (hex)} - test empty input, block-aligned, multi-block, large inputs\n- sha512_vectors: array of {input (hex), expected (hex)}\n\nAdd tracing::trace! for each hash computation showing input length and output.\n\nProperty tests (proptest):\n- sha256 output is always exactly 32 bytes\n- sha512 output is always exactly 64 bytes\n- Same input always produces same output (deterministic)\n- Different inputs produce different outputs (collision resistance spot check)\n\nAcceptance: All test vectors pass, proptest passes, tracing output visible at trace level.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:17:56.338879063Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.551207687Z","closed_at":"2026-02-12T19:12:31.551207687Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.1","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:17:56.339459136Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.2","title":"Implement HMAC-SHA256","description":"Implement HMAC-SHA256 using the hmac crate:\n\nfn hmac_sha256(key: \u0026[u8], message: \u0026[u8]) -\u003e [u8; 32]\nfn hmac_sha256_verify(key: \u0026[u8], message: \u0026[u8], expected: \u0026[u8; 32]) -\u003e bool\n\nTest against token.json -\u003e hmac_sha256 array, which contains:\n- Array of {key (hex), message (hex), digest (hex)}\n- Verify computed HMAC matches expected digest for each vector\n\nAdd tracing::trace! showing key length and message length.\n\nProperty tests:\n- Output is always 32 bytes\n- Deterministic (same key+message = same HMAC)\n- Different keys produce different HMACs for same message\n- Verify function returns true for correct HMAC, false for corrupted HMAC\n\nEdge cases: empty message, empty key, very long key (longer than block size), single-byte inputs.\n\nAcceptance: All token.json hmac vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:17:59.117527375Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.583381212Z","closed_at":"2026-02-12T19:12:31.583381212Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.2","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:17:59.118072158Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.2","depends_on_id":"Rusticulum-sed.1","type":"blocks","created_at":"2026-02-08T03:23:28.442157088Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.3","title":"Implement HKDF-SHA256 (RFC 5869)","description":"Implement HKDF-SHA256 per RFC 5869 with Reticulum-specific behavior:\n\nfn hkdf(length: usize, ikm: \u0026[u8], salt: \u0026[u8], info: \u0026[u8]) -\u003e Vec\u003cu8\u003e\n\nAlso expose the intermediate PRK for test vector validation:\nfn hkdf_extract(salt: \u0026[u8], ikm: \u0026[u8]) -\u003e [u8; 32]  // returns PRK\nfn hkdf_expand(prk: \u0026[u8; 32], info: \u0026[u8], length: usize) -\u003e Vec\u003cu8\u003e\n\nCRITICAL protocol subtleties:\n- When salt is empty or None, use 32 zero bytes (NOT the HMAC default behavior - be explicit)\n- The expand phase counter is (i+1) % 256 where i is 0-indexed\n- These are documented in implementation plan Part 8 points 1 and 2\n\nTest against hkdf.json which contains:\n- rfc5869_vectors: array of {ikm, salt, info, length, prk, okm} - standard RFC 5869 test cases\n- reticulum_vector: {shared_key, salt, info, length, prk, derived_key} - Reticulum ECDH key derivation case\n- Verify both PRK (intermediate) and OKM/derived_key (final output)\n\nAdd tracing::debug! for key derivation operations showing IKM length, salt length, output length.\n\nProperty tests:\n- Output length matches requested length\n- Deterministic\n- Different IKM produces different output\n- Empty salt produces same result as 32-zero-byte salt\n\nAcceptance: All RFC 5869 vectors pass, Reticulum vector passes, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:03.10267216Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.601319609Z","closed_at":"2026-02-12T19:12:31.601319609Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.3","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:03.103217453Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.3","depends_on_id":"Rusticulum-sed.2","type":"blocks","created_at":"2026-02-08T03:23:29.302569392Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.4","title":"Implement PKCS7 padding","description":"Implement PKCS7 padding and unpadding for 16-byte block size:\n\nfn pkcs7_pad(data: \u0026[u8], block_size: usize) -\u003e Vec\u003cu8\u003e\nfn pkcs7_unpad(data: \u0026[u8], block_size: usize) -\u003e Result\u003c\u0026[u8], CryptoError\u003e\n\nThe block size for Reticulum is always 16 (AES block size).\n\nPadding rules:\n- If data length is multiple of block_size, add full block of padding bytes (each byte = block_size)\n- Otherwise pad to next multiple, each pad byte = number of pad bytes added\n- Unpad: read last byte as pad length, verify all pad bytes match, strip\n\nTest against token.json -\u003e pkcs7_padding array:\n- Array of {input (hex), block_size (int), padded (hex)}\n- Test pad: verify padded output matches\n- Test unpad: verify unpadded output matches original input\n\nAdd tracing::trace! for pad/unpad operations.\n\nProperty tests:\n- Padded output length is always multiple of block_size\n- Padded output is always longer than input (at least 1 byte, at most block_size bytes added)\n- Round-trip: unpad(pad(data)) == data for any input\n- Unpad rejects data with invalid padding bytes\n- Unpad rejects empty input\n- Unpad rejects data where last byte is 0 or \u003e block_size\n\nEdge cases: empty input, input exactly block_size, input one byte less than block_size, very large input.\n\nAcceptance: All token.json pkcs7 vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:06.897111606Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.619500256Z","closed_at":"2026-02-12T19:12:31.619500256Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.4","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:06.897781823Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.5","title":"Implement AES-256-CBC encryption/decryption","description":"Implement AES-256-CBC using the aes and cbc crates:\n\nfn aes256_cbc_encrypt(key: \u0026[u8; 32], iv: \u0026[u8; 16], plaintext: \u0026[u8]) -\u003e Vec\u003cu8\u003e\nfn aes256_cbc_decrypt(key: \u0026[u8; 32], iv: \u0026[u8; 16], ciphertext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e\n\nEncrypt applies PKCS7 padding before encryption. Decrypt removes PKCS7 padding after decryption.\n\nThis is tested indirectly through the Token module (step 6), but should have its own unit tests:\n- Known key + IV + plaintext -\u003e expected ciphertext\n- Round-trip: decrypt(encrypt(data)) == data\n- Decrypt rejects truncated ciphertext\n- Decrypt rejects ciphertext not aligned to block size\n\nAdd tracing::trace! for encrypt/decrypt showing data lengths.\n\nProperty tests:\n- Ciphertext length is always multiple of 16\n- Ciphertext length \u003e= plaintext length + 1 (at least 1 byte padding)\n- Round-trip: decrypt(encrypt(data)) == data for any input\n- Different IVs produce different ciphertext for same key+plaintext\n- Different keys produce different ciphertext for same IV+plaintext\n\nAcceptance: Unit tests pass, proptests pass, ready for Token integration.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:10.92738418Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.637694354Z","closed_at":"2026-02-12T19:12:31.637694354Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.5","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:10.927948883Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.5","depends_on_id":"Rusticulum-sed.4","type":"blocks","created_at":"2026-02-08T03:23:30.048912512Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.6","title":"Implement Token (modified Fernet) encryption","description":"Implement the Token module - Reticulum's modified Fernet symmetric encryption:\n\nstruct Token { signing_key: [u8; 32], encryption_key: [u8; 32] }\n\nimpl Token {\n    fn new(key: \u0026[u8; 64]) -\u003e Self;  // CRITICAL: signing_key = key[0:32], encryption_key = key[32:64]\n    fn encrypt(\u0026self, plaintext: \u0026[u8]) -\u003e Vec\u003cu8\u003e;\n    fn decrypt(\u0026self, token: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n    // For deterministic test vectors:\n    fn encrypt_with_iv(\u0026self, plaintext: \u0026[u8], iv: \u0026[u8; 16]) -\u003e Vec\u003cu8\u003e;\n}\n\nToken format (differs from standard Fernet - NO version byte, NO timestamp):\n  output = IV(16) || AES-256-CBC(PKCS7(plaintext)) || HMAC-SHA256(signing_key, IV || ciphertext)\n\nCRITICAL key split (implementation plan Part 8 point 10):\n  signing_key = key[0:32]    (FIRST 32 bytes)\n  encryption_key = key[32:64] (LAST 32 bytes)\n  This is the OPPOSITE of what you might expect!\n\nEncrypt:\n1. Generate random 16-byte IV (or use provided IV for testing)\n2. Pad plaintext with PKCS7\n3. Encrypt with AES-256-CBC using encryption_key and IV\n4. Compute HMAC-SHA256(signing_key, IV || ciphertext)\n5. Return IV || ciphertext || HMAC(32 bytes)\n\nDecrypt:\n1. Split: IV = token[0:16], ciphertext = token[16:len-32], hmac = token[len-32:]\n2. Verify HMAC-SHA256(signing_key, IV || ciphertext) == hmac\n3. Decrypt AES-256-CBC with encryption_key and IV\n4. Remove PKCS7 padding\n5. Return plaintext\n\nTOKEN_OVERHEAD = 48 bytes (16 IV + 32 HMAC)\n\nTest against token.json -\u003e encryption_vectors:\n- Array of {key (hex, 64 bytes), plaintext (hex), iv (hex), ciphertext_with_hmac (hex)}\n- Use encrypt_with_iv to get deterministic output, compare with expected\n- Use decrypt on ciphertext_with_hmac, verify plaintext matches\n\nAdd tracing::debug! for encrypt/decrypt operations showing plaintext length.\n\nProperty tests:\n- Token output is always plaintext_len + padding + 48 bytes overhead\n- Round-trip: decrypt(encrypt(data)) == data\n- Decrypt rejects tokens with corrupted HMAC\n- Decrypt rejects tokens with corrupted ciphertext\n- Decrypt rejects tokens shorter than 48 bytes (minimum overhead)\n- Different random IVs produce different tokens\n\nAcceptance: All token.json encryption vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:17.951392394Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.655909853Z","closed_at":"2026-02-12T19:12:31.655909853Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.6","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:17.952091013Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.6","depends_on_id":"Rusticulum-sed.2","type":"blocks","created_at":"2026-02-08T03:23:31.190512809Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.6","depends_on_id":"Rusticulum-sed.5","type":"blocks","created_at":"2026-02-08T03:23:31.748496774Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.7","title":"Implement X25519 Diffie-Hellman key exchange","description":"Implement X25519 ECDH using x25519-dalek:\n\nstruct X25519PrivateKey(x25519_dalek::StaticSecret);\nstruct X25519PublicKey(x25519_dalek::PublicKey);  // wraps [u8; 32]\n\nimpl X25519PrivateKey {\n    fn generate() -\u003e Self;\n    fn from_bytes(bytes: \u0026[u8; 32]) -\u003e Self;\n    fn public_key(\u0026self) -\u003e X25519PublicKey;\n    fn diffie_hellman(\u0026self, their_public: \u0026X25519PublicKey) -\u003e [u8; 32];  // shared secret\n}\n\nTest against keypairs.json -\u003e shared_secrets:\n- Array of {keypair_a (index), keypair_b (index), shared_secret (hex)}\n- Load private keys from keypairs array using x25519_private field\n- Compute DH exchange between keypair_a and keypair_b\n- Verify shared_secret matches expected\n\nAlso verify:\n- From keypairs.json keypairs array: load x25519_private, derive public key, verify matches x25519_public\n\nAdd tracing::debug! for key generation and DH exchange.\n\nProperty tests:\n- Public key is always 32 bytes\n- DH is commutative: A.dh(B.pub) == B.dh(A.pub)\n- Different keypairs produce different shared secrets (usually)\n- Generated keys produce valid public keys\n\nAcceptance: All keypairs.json shared_secret vectors pass, public key derivation matches, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:22.123233811Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.674421754Z","closed_at":"2026-02-12T19:12:31.674421754Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.7","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:22.123824046Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.8","title":"Implement Ed25519 digital signatures","description":"Implement Ed25519 signing and verification using ed25519-dalek:\n\nstruct Ed25519PrivateKey(ed25519_dalek::SigningKey);\nstruct Ed25519PublicKey(ed25519_dalek::VerifyingKey);  // wraps [u8; 32]\nstruct Signature([u8; 64]);  // SIGLENGTH = 64\n\nimpl Ed25519PrivateKey {\n    fn generate() -\u003e Self;\n    fn from_bytes(bytes: \u0026[u8; 32]) -\u003e Self;\n    fn public_key(\u0026self) -\u003e Ed25519PublicKey;\n    fn sign(\u0026self, message: \u0026[u8]) -\u003e Signature;\n}\n\nimpl Ed25519PublicKey {\n    fn from_bytes(bytes: \u0026[u8; 32]) -\u003e Result\u003cSelf, CryptoError\u003e;\n    fn verify(\u0026self, message: \u0026[u8], signature: \u0026Signature) -\u003e bool;\n}\n\nTest against keypairs.json -\u003e signature_vectors:\n- Array of {keypair_index (int), message (hex), signature (hex)}\n- Load ed25519_private from keypairs[keypair_index]\n- Sign message, verify signature matches expected 64-byte signature\n- Also verify using public key\n\nAlso verify:\n- From keypairs array: load ed25519_private, derive public key, verify matches ed25519_public\n\nAdd tracing::debug! for sign/verify operations.\n\nProperty tests:\n- Signature is always 64 bytes\n- Sign then verify succeeds for same message\n- Verify fails for wrong message\n- Verify fails for wrong public key\n- Verify fails for corrupted signature\n\nAcceptance: All keypairs.json signature vectors pass, public key derivation matches, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:26.107258267Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.692276708Z","closed_at":"2026-02-12T19:12:31.692276708Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.8","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:26.107787249Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj","title":"Transport Layer (reticulum-transport)","description":"Implement routing, announce propagation, path tables, packet deduplication, and interface access codes (IFAC). Includes: router (packet dispatch, destination registry), path_table (entries with TTL: 7 days normal, 1 day AP, 6h roaming), announce propagation (2% bandwidth cap, hop limit 128, dedup), dedup (1M entry hash set, 50% culling), IFAC (hardcoded salt, HMAC suffix). Depends on reticulum-protocol. Uses async (tokio).","status":"closed","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:53.619626622Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T01:32:15.067970178Z","closed_at":"2026-02-13T01:32:15.067970178Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-uqj","depends_on_id":"Rusticulum-c7u","type":"blocks","created_at":"2026-02-08T03:15:08.65728948Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.1","title":"Implement path table with TTL enforcement","description":"Implement the path table for storing discovered routes:\n\npub struct PathEntry {\n    pub destination: DestinationHash,\n    pub next_hop: Option\u003cDestinationHash\u003e,  // None for direct\n    pub interface: InterfaceId,\n    pub hops: u8,\n    pub expires_at: Instant,\n    pub announce_hash: PacketHash,\n    pub created_at: Instant,\n}\n\npub struct PathTable {\n    entries: HashMap\u003cDestinationHash, PathEntry\u003e,\n}\n\nTTL values (time-to-live for path entries):\n- Normal path: 7 days (604800 seconds)\n- Access Point (AP) path: 1 day (86400 seconds)\n- Roaming path: 6 hours (21600 seconds)\n\nimpl PathTable {\n    pub fn new() -\u003e Self;\n    pub fn insert(\u0026mut self, entry: PathEntry);\n    pub fn lookup(\u0026self, destination: \u0026DestinationHash) -\u003e Option\u003c\u0026PathEntry\u003e;\n    pub fn remove(\u0026mut self, destination: \u0026DestinationHash);\n    pub fn expire(\u0026mut self, now: Instant);  // Remove expired entries\n    pub fn len(\u0026self) -\u003e usize;\n    pub fn is_empty(\u0026self) -\u003e bool;\n}\n\nTest against path_requests.json and path_expiration.json:\n- Path entry creation with correct TTLs\n- Lookup returns correct entries\n- Expiration removes entries past TTL\n- Newer announces update existing entries\n\nAdd tracing::debug! for path table operations (insert/lookup/expire), info! for table size changes.\n\nProperty tests:\n- Expired entries are never returned by lookup\n- Insert then lookup returns the entry\n- Entries with different TTL types expire at correct times\n- Table size decreases after expire() when entries are stale\n\nAcceptance: All path test vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:26.121115625Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T01:32:15.016075515Z","closed_at":"2026-02-13T01:32:15.016075515Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-uqj.1","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:26.121731981Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.2","title":"Implement announce propagation with rate limiting","description":"Implement announce propagation rules:\n\npub struct AnnouncePropagation {\n    bandwidth_cap: f64,          // 2% of interface bandwidth\n    hop_limit: u8,               // Maximum 128 hops\n    seen_announces: HashSet\u003cPacketHash\u003e,  // Deduplication\n    rate_tracker: BandwidthTracker,\n}\n\nPropagation rules:\n- Rate limiting: announces must not exceed 2% of interface bandwidth\n- Hop limit: announces with hops \u003e= 128 are dropped\n- Deduplication: announce packet_hash is tracked, duplicates are dropped\n- Hop increment: hops field is incremented before forwarding\n- Retransmit delay: based on hop count and interface bitrate\n\nimpl AnnouncePropagation {\n    pub fn new(bandwidth_bps: u64) -\u003e Self;\n    pub fn should_propagate(\u0026mut self, announce: \u0026RawPacket) -\u003e PropagateDecision;\n    pub fn record_propagation(\u0026mut self, size: usize);\n    pub fn increment_hops(\u0026self, packet: \u0026mut RawPacket);\n}\n\npub enum PropagateDecision {\n    Propagate,\n    Drop(DropReason),\n    Delay(Duration),\n}\n\npub enum DropReason {\n    HopLimitExceeded,\n    Duplicate,\n    RateLimited,\n}\n\nTest against announces.json (propagation rules section if present):\n- Verify hop counting\n- Verify deduplication\n- Verify rate limiting behavior\n\nAdd tracing::info! for propagated announces, warn! for dropped announces, debug! for rate limiting decisions.\n\nProperty tests:\n- Announces with hops \u003e= 128 are always dropped\n- Same announce is never propagated twice\n- Bandwidth usage stays within 2% cap over time\n- Hops always increment by 1\n\nAcceptance: Propagation rules match reference implementation behavior, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:32.200375785Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T01:32:15.033464333Z","closed_at":"2026-02-13T01:32:15.033464333Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-uqj.2","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:32.201079755Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-uqj.2","depends_on_id":"Rusticulum-uqj.1","type":"blocks","created_at":"2026-02-08T03:36:19.880198886Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.3","title":"Implement packet router and destination registry","description":"Implement the central packet router:\n\npub struct Router {\n    destinations: HashMap\u003cDestinationHash, DestinationInfo\u003e,\n    path_table: PathTable,\n    announce_propagation: AnnouncePropagation,\n    interfaces: Vec\u003cInterfaceId\u003e,\n}\n\npub struct DestinationInfo {\n    pub destination_type: DestinationType,\n    pub handler: Box\u003cdyn PacketHandler\u003e,\n    pub proof_strategy: ProofStrategy,\n}\n\npub enum ProofStrategy {\n    ProveNone,\n    ProveApp,\n    ProveAll,\n}\n\nimpl Router {\n    pub fn new() -\u003e Self;\n    pub fn register_destination(\u0026mut self, hash: DestinationHash, info: DestinationInfo);\n    pub fn unregister_destination(\u0026mut self, hash: \u0026DestinationHash);\n    pub fn route_packet(\u0026mut self, packet: \u0026RawPacket, source_interface: InterfaceId) -\u003e Vec\u003cRouterAction\u003e;\n    pub fn lookup_path(\u0026self, destination: \u0026DestinationHash) -\u003e Option\u003c\u0026PathEntry\u003e;\n}\n\npub enum RouterAction {\n    DeliverLocal(DestinationHash, Vec\u003cu8\u003e),\n    Forward(InterfaceId, Vec\u003cu8\u003e),\n    Broadcast(Vec\u003cu8\u003e),\n    Drop(DropReason),\n}\n\nRouting logic:\n1. Check packet dedup (drop if seen)\n2. For announces: validate, update path table, propagate per rules\n3. For data/proof: lookup destination, deliver locally or forward via path table\n4. For link requests: deliver to destination if registered\n5. For HEADER_2 (transport): strip transport header, re-route\n\nTest against multi_hop_routing.json:\n- Multi-hop packet forwarding\n- Transport header insertion/removal\n- Correct interface selection for forwarding\n\nAdd tracing::info! for packet routing decisions, debug! for path lookups, warn! for dropped packets.\n\nProperty tests:\n- Registered destinations receive their packets\n- Unregistered destinations result in forwarding or drop\n- Duplicate packets are never delivered\n- HEADER_2 transport_id is correctly handled\n\nAcceptance: All multi_hop_routing.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:44.042672506Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T01:32:15.050674813Z","closed_at":"2026-02-13T01:32:15.050674813Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-uqj.3","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:44.043224409Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-uqj.3","depends_on_id":"Rusticulum-uqj.1","type":"blocks","created_at":"2026-02-08T03:36:22.920602986Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-uqj.3","depends_on_id":"Rusticulum-uqj.2","type":"blocks","created_at":"2026-02-08T03:36:26.202606067Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-uqj.3","depends_on_id":"Rusticulum-uqj.4","type":"blocks","created_at":"2026-02-08T03:36:29.76839612Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.4","title":"Implement packet deduplication","description":"Implement the packet hash deduplication system:\n\npub struct PacketDedup {\n    seen: HashSet\u003cPacketHash\u003e,\n    max_entries: usize,  // 1,000,000 (1M)\n}\n\nimpl PacketDedup {\n    pub fn new() -\u003e Self;\n    pub fn is_duplicate(\u0026mut self, hash: \u0026PacketHash) -\u003e bool;\n    pub fn record(\u0026mut self, hash: PacketHash);\n    pub fn len(\u0026self) -\u003e usize;\n    \n    // When entries exceed max, cull 50%\n    fn cull(\u0026mut self);\n}\n\nCulling strategy:\n- Maximum 1,000,000 entries\n- When max is reached, remove 50% of entries (500,000)\n- Culling should remove older entries (FIFO-like behavior)\n- Consider using a VecDeque or similar ordered structure for age-based culling\n\nAdd tracing::info! for culling events (count before/after), debug! for duplicate detection.\n\nProperty tests:\n- After recording, is_duplicate returns true\n- After culling, size is approximately 50% of max\n- Size never exceeds max_entries (or only briefly before cull)\n- Fresh hashes are never marked as duplicates\n\nAcceptance: Dedup handles 1M+ insertions correctly, culling works, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:49.030856482Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T01:32:14.981802379Z","closed_at":"2026-02-13T01:32:14.981802379Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-uqj.4","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:49.031380953Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.5","title":"Implement Interface Access Codes (IFAC)","description":"Implement IFAC for interface authentication:\n\nIFAC uses a hardcoded salt and HMAC to compute a suffix that is appended to packets for interface-level access control.\n\npub struct Ifac {\n    hmac_key: [u8; 32],  // Derived from interface access code + hardcoded salt\n}\n\nimpl Ifac {\n    pub fn new(access_code: \u0026[u8]) -\u003e Self;\n    pub fn compute_suffix(\u0026self, packet_data: \u0026[u8]) -\u003e Vec\u003cu8\u003e;  // HMAC suffix\n    pub fn verify(\u0026self, packet_data: \u0026[u8], suffix: \u0026[u8]) -\u003e bool;\n    pub fn sign_packet(\u0026self, packet: \u0026[u8]) -\u003e Vec\u003cu8\u003e;  // packet + suffix\n    pub fn verify_and_strip(\u0026self, signed_packet: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, IfacError\u003e;\n}\n\nThe IFAC key is derived from the access code string using a hardcoded salt value defined in the reference implementation.\n\nAdd tracing::debug! for IFAC operations, warn! for verification failures.\n\nProperty tests:\n- verify(data, compute_suffix(data)) always returns true\n- Different access codes produce different suffixes\n- Corrupted suffix fails verification\n- Round-trip: verify_and_strip(sign_packet(data)) == data\n\nAcceptance: IFAC computation matches reference implementation, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:57.05106736Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T01:32:14.99901259Z","closed_at":"2026-02-13T01:32:14.99901259Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-uqj.5","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:57.051737147Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.6","title":"Implement transport error types","description":"Define error types for the transport crate:\n\n#[derive(Debug, thiserror::Error)]\npub enum RouterError {\n    #[error(\"no path to destination {0}\")]\n    NoPath(DestinationHash),\n    #[error(\"destination not registered: {0}\")]\n    NotRegistered(DestinationHash),\n    #[error(\"packet too large: {size} \u003e {max}\")]\n    PacketTooLarge { size: usize, max: usize },\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum PathError { ... }\n\n#[derive(Debug, thiserror::Error)]\npub enum IfacError { ... }\n\nAcceptance: All error types compile, provide useful messages.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:36:02.997230021Z","created_by":"Matthew Remmel","updated_at":"2026-02-13T01:32:14.952698674Z","closed_at":"2026-02-13T01:32:14.952698674Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-uqj.6","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:36:02.9979342Z","created_by":"Matthew Remmel"}]}
