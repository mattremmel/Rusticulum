{"id":"Rusticulum-3a5","title":"Integration Testing and Interop","description":"End-to-end integration testing with the Python reference implementation. Includes: Docker compose setup with Python reference node, announce exchange (bidirectional), link establishment (bidirectional), resource transfer (bidirectional), channel/buffer protocol testing, multi-hop routing through mixed Rust/Python transport nodes. This validates full protocol interoperability.","status":"open","priority":1,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:15:01.162928977Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:15:01.162928977Z","dependencies":[{"issue_id":"Rusticulum-3a5","depends_on_id":"Rusticulum-nrn","type":"blocks","created_at":"2026-02-08T03:15:08.695214477Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.1","title":"Set up Docker environment with Python reference node","description":"Create a Docker Compose configuration that runs both the Rust Reticulum implementation and the Python reference implementation (v1.1.3) as peer nodes:\n\nDocker setup:\n- Dockerfile for Rust node (build from workspace, run reticulum-node binary)\n- Dockerfile or image for Python Reticulum reference (pip install rns==1.1.3)\n- docker-compose.yml with both services on a shared network\n- Shared TCP interface configuration so nodes can communicate\n- Volume mounts for identity persistence and logs\n- Health checks for both nodes\n\nConfiguration:\n- Python node config: TCP interface listening on a known port\n- Rust node config: TCP interface connecting to Python node\n- Both nodes with transport enabled for multi-hop testing\n- Separate network segments for multi-hop scenarios (requires 3+ nodes)\n\nTest runner:\n- Script to start the environment, wait for nodes to be ready, run integration tests, collect results\n- Support for running individual test scenarios\n- Log collection from both nodes for debugging\n\nAdd tracing integration: Rust node logs should be structured JSON for easy parsing in test assertions.\n\nAcceptance: docker-compose up starts both nodes, they can reach each other via TCP, logs are accessible.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:39:45.809419943Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:39:45.809419943Z","dependencies":[{"issue_id":"Rusticulum-3a5.1","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:39:45.810161043Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.2","title":"Test bidirectional announce exchange","description":"Integration test: verify announce packets are correctly exchanged between Rust and Python nodes.\n\nTest scenarios:\n1. Rust announces, Python validates:\n   - Rust node creates a destination with known app_name/aspects\n   - Rust node sends announce\n   - Python node receives and validates the announce (signature, destination hash)\n   - Verify Python node has the Rust destination in its known destinations\n\n2. Python announces, Rust validates:\n   - Python node creates a destination\n   - Python node sends announce  \n   - Rust node receives and validates the announce\n   - Verify Rust node has the Python destination in its path table\n\n3. Announce with app_data:\n   - Both directions with optional app_data payload\n   - Verify app_data is preserved\n\n4. Announce with ratchet:\n   - Both directions with ratchet key\n   - Verify ratchet is correctly propagated\n\nValidation:\n- Destination hashes match between implementations\n- Signatures verify correctly cross-implementation\n- Path table entries are created with correct TTLs\n- Announce propagation follows rate limiting rules\n\nAcceptance: All announce scenarios pass bidirectionally between Rust and Python nodes.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:39:50.942587987Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:39:50.942587987Z","dependencies":[{"issue_id":"Rusticulum-3a5.2","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:39:50.943185042Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.2","depends_on_id":"Rusticulum-3a5.1","type":"blocks","created_at":"2026-02-08T03:40:40.138226634Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.3","title":"Test bidirectional link establishment","description":"Integration test: verify link handshake works between Rust and Python implementations.\n\nTest scenarios:\n1. Rust initiator, Python responder:\n   - Rust node initiates link to Python destination\n   - 3-packet handshake completes (LINKREQUEST -\u003e LRPROOF -\u003e LRRTT)\n   - Both sides derive same key (verified by successful encrypt/decrypt)\n   - Link enters Active state on both sides\n\n2. Python initiator, Rust responder:\n   - Python node initiates link to Rust destination\n   - Same handshake verification\n   - Link Active on both sides\n\n3. Link with MTU signalling:\n   - Negotiate non-default MTU during handshake\n   - Verify both sides agree on effective MDU\n\n4. Link keepalive:\n   - Established link stays alive with keepalive packets\n   - Verify keepalive interval is computed consistently\n\n5. Link close:\n   - Graceful link close from both sides\n   - Verify both sides transition to Closed state\n\n6. Data over link:\n   - Send data packets over established link\n   - Verify encryption/decryption works cross-implementation\n   - Send maximum-size data (MDU)\n   - Send minimal data (1 byte)\n\nAcceptance: Links can be established and used for encrypted communication in both directions.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:39:59.940958252Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:39:59.940958252Z","dependencies":[{"issue_id":"Rusticulum-3a5.3","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:39:59.94139723Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.3","depends_on_id":"Rusticulum-3a5.1","type":"blocks","created_at":"2026-02-08T03:40:45.590014648Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.3","depends_on_id":"Rusticulum-3a5.2","type":"blocks","created_at":"2026-02-08T03:40:45.612229936Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.4","title":"Test bidirectional resource transfers","description":"Integration test: verify resource transfer protocol works between implementations.\n\nTest scenarios:\n1. Rust sends resource to Python:\n   - Create resource from known data\n   - Advertise resource over established link\n   - Transfer all parts\n   - Python verifies resource proof\n   - Python has correct reassembled data\n\n2. Python sends resource to Rust:\n   - Same flow in reverse direction\n   - Rust validates and reassembles correctly\n\n3. Small resource (single part):\n   - Data fits in one part\n   - Verify advertisement, transfer, proof\n\n4. Large resource (multiple parts):\n   - Data requires multiple parts and window management\n   - Verify all parts transfer correctly\n   - Verify window adaptation occurs\n\n5. Resource with compression:\n   - Data that benefits from compression\n   - Verify compressed transfer works\n\n6. Segmented resource:\n   - Resource exceeding MAX_EFFICIENT_SIZE (1,048,575 bytes)\n   - Verify segmentation and reassembly\n\n7. Failed transfer recovery:\n   - Simulate packet loss (drop random parts)\n   - Verify retransmission and eventual success\n\nAcceptance: Resources transfer correctly in both directions for all size classes.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:40:04.424228354Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:40:04.424228354Z","dependencies":[{"issue_id":"Rusticulum-3a5.4","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:40:04.424786197Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.4","depends_on_id":"Rusticulum-3a5.3","type":"blocks","created_at":"2026-02-08T03:40:48.54454401Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.5","title":"Test channel and buffer protocols","description":"Integration test: verify channel and buffer protocols work between implementations.\n\nTest scenarios:\n1. Channel messages:\n   - Send channel messages from Rust to Python and vice versa\n   - Verify envelope packing/unpacking is compatible\n   - Verify sequence numbers are tracked correctly\n   - Test window flow control\n\n2. Buffer stream:\n   - Stream data from Rust to Python using buffer protocol\n   - Stream data from Python to Rust\n   - Verify stream header encoding is compatible\n   - Verify EOF detection works\n   - Test with compressed and uncompressed data\n\n3. Request/Response:\n   - Rust sends request, Python responds\n   - Python sends request, Rust responds\n   - Verify msgpack encoding is compatible\n   - Test with various payload sizes\n\n4. Channel with many messages:\n   - Send enough messages to trigger sequence wrapping (65536+)\n   - Verify wrapping is handled correctly on both sides\n\n5. Buffer with large data:\n   - Stream data larger than a single chunk\n   - Verify chunking and reassembly\n\nAcceptance: All channel/buffer/request-response scenarios pass bidirectionally.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:40:09.208374617Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:40:09.208374617Z","dependencies":[{"issue_id":"Rusticulum-3a5.5","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:40:09.208973792Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.5","depends_on_id":"Rusticulum-3a5.3","type":"blocks","created_at":"2026-02-08T03:40:52.815901389Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.6","title":"Test multi-hop routing through mixed nodes","description":"Integration test: verify multi-hop routing works through mixed Rust/Python transport nodes.\n\nTest scenarios:\n1. Three-node chain: Rust -\u003e Python -\u003e Rust\n   - Source Rust node sends to destination Rust node\n   - Python node acts as transport relay\n   - Verify packet is forwarded correctly\n   - Verify transport headers are correctly inserted/removed\n\n2. Three-node chain: Python -\u003e Rust -\u003e Python\n   - Same but Rust acts as relay\n   - Verify Rust correctly forwards packets\n\n3. Announce propagation through relay:\n   - Announce originates at one end\n   - Propagates through relay\n   - Reaches far end with incremented hop count\n\n4. Path discovery through relay:\n   - Destination is only reachable through relay\n   - Path table correctly records multi-hop path\n   - Data flows through the discovered path\n\n5. Four-node topology:\n   - A -\u003e B -\u003e C -\u003e D with mixed implementations\n   - Verify end-to-end communication\n   - Verify path table entries at each hop\n\n6. Link through relay:\n   - Establish link between non-adjacent nodes\n   - Verify encrypted link works over multiple hops\n\nAcceptance: Multi-hop routing works correctly through any mix of Rust and Python nodes.","status":"open","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:40:14.230787344Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:40:14.230787344Z","dependencies":[{"issue_id":"Rusticulum-3a5.6","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:40:14.231327306Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.6","depends_on_id":"Rusticulum-3a5.1","type":"blocks","created_at":"2026-02-08T03:40:56.802356471Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.6","depends_on_id":"Rusticulum-3a5.2","type":"blocks","created_at":"2026-02-08T03:40:56.823660831Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.6","depends_on_id":"Rusticulum-3a5.3","type":"blocks","created_at":"2026-02-08T03:40:56.845630678Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-3a5.7","title":"Comprehensive cross-implementation compatibility test suite","description":"Create a comprehensive test suite that validates full protocol compatibility:\n\n1. Deterministic test suite:\n   - Run all JSON test vectors through both Rust and Python implementations\n   - Verify both produce identical outputs for identical inputs\n   - Compare: hashes, signatures, encrypted outputs, packet encodings, announce payloads\n\n2. Fuzz testing:\n   - Generate random valid packets with proptest\n   - Feed to Python implementation for validation\n   - Feed Python-generated packets to Rust for validation\n   - Verify no crashes or protocol violations\n\n3. Stress testing:\n   - Many concurrent links\n   - Many simultaneous resource transfers\n   - Rapid announce bursts\n   - Connection drops and reconnects\n\n4. Edge case testing:\n   - Maximum size packets (MTU=500)\n   - Minimum size packets\n   - Empty payloads where allowed\n   - Maximum hop count announces\n   - Expired path entries\n   - Duplicate packet handling\n\n5. Protocol version compatibility:\n   - Verify Rust implementation correctly handles all packet types\n   - Verify no unknown context types cause crashes\n   - Graceful handling of malformed packets\n\nCreate a CI-runnable test suite that can be run against any pair of implementations.\n\nAcceptance: Full compatibility test suite passes, documenting any known differences.","status":"open","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:40:20.692829323Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:40:20.692829323Z","dependencies":[{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5","type":"parent-child","created_at":"2026-02-08T03:40:20.693378895Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.2","type":"blocks","created_at":"2026-02-08T03:41:01.397837484Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.3","type":"blocks","created_at":"2026-02-08T03:41:01.419810632Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.4","type":"blocks","created_at":"2026-02-08T03:41:01.441351992Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.5","type":"blocks","created_at":"2026-02-08T03:41:01.462982996Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-3a5.7","depends_on_id":"Rusticulum-3a5.6","type":"blocks","created_at":"2026-02-08T03:41:01.484707513Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m","title":"Workspace \u0026 Project Setup","description":"Set up the Cargo workspace with all six crates (reticulum-crypto, reticulum-core, reticulum-protocol, reticulum-transport, reticulum-interfaces, reticulum-node), workspace-level dependencies, test vector infrastructure, and CI/tooling configuration. This is the foundation everything else builds on.","status":"closed","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:36.994738678Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:29:04.267935893Z","closed_at":"2026-02-12T18:29:04.267935893Z","close_reason":"Closed"}
{"id":"Rusticulum-97m.1","title":"Initialize Cargo workspace with all six crates","description":"Create the top-level Cargo.toml with [workspace] configuration listing all six member crates: reticulum-crypto, reticulum-core, reticulum-protocol, reticulum-transport, reticulum-interfaces, reticulum-node. Set up workspace-level dependency versions for all shared dependencies as specified in the implementation plan Part 6:\n\nCrypto: sha2=0.10, hmac=0.12, hkdf=0.12, aes=0.8, cbc=0.1, x25519-dalek=2, ed25519-dalek=2, rand=0.8\nSerialization: serde=1 (with derive), serde_json=1, rmpv=1, hex=0.4\nAsync: tokio=1 (full features)\nCompression: bzip2=0.4\nError: thiserror=2\nLogging: tracing=0.1\nCLI: clap=4 (derive feature)\nTesting: criterion=0.5, proptest (for property-based tests)\n\nEach crate gets its own Cargo.toml inheriting workspace dependencies. Set edition=2024 for all crates. Create minimal lib.rs files for each crate. The dependency graph is:\n- reticulum-crypto: leaf crate, no internal deps\n- reticulum-core: depends on reticulum-crypto\n- reticulum-protocol: depends on reticulum-core\n- reticulum-transport: depends on reticulum-protocol\n- reticulum-interfaces: depends on reticulum-core (for framing)\n- reticulum-node: depends on all other crates\n\nAcceptance: 'cargo build' succeeds with all crates, 'cargo test' runs (even if no tests yet).","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:04.340866205Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T17:51:34.505370731Z","closed_at":"2026-02-12T17:51:34.505370731Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.1","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:04.341533033Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m.2","title":"Set up no_std feature flags for crypto and core crates","description":"Configure reticulum-crypto and reticulum-core Cargo.toml files with optional no_std support:\n\n[features]\ndefault = ['std']\nstd = []\n\nWhen std is disabled, use #![no_std] with extern crate alloc. Ensure all types use alloc::vec::Vec, alloc::string::String instead of std equivalents. Add conditional compilation attributes throughout. Avoid std::time, std::net, etc. in these crates.\n\nAcceptance: Both crates compile with --no-default-features (once they have content).","status":"closed","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:07.745225569Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:00:34.972903124Z","closed_at":"2026-02-12T18:00:34.972903124Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.2","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:07.745764971Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-97m.2","depends_on_id":"Rusticulum-97m.1","type":"blocks","created_at":"2026-02-08T03:16:34.915916706Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m.3","title":"Set up test vector infrastructure","description":"Create the test vector loading infrastructure. The .test-vectors/ directory contains 17 JSON files. Create a shared test utilities module or approach for loading test vectors using include_str!() and serde_json::from_str().\n\nDefine serde-deserializable structs for each test vector file format (can be in a test-support module or within each crate's test modules). The schemas are defined in the implementation plan Part 5:\n\n- hashes.json: sha256_vectors/sha512_vectors arrays with input/expected fields\n- keypairs.json: keypairs array with all key material, signature_vectors, shared_secrets\n- hkdf.json: rfc5869_vectors array with ikm/salt/info/length/prk/okm, reticulum_vector\n- token.json: pkcs7_padding, hmac_sha256, encryption_vectors arrays\n- destination_hashes.json: single_destinations array\n- packet_headers.json: header_vectors array with flag byte layouts\n- packets_data.json: packet data arrays\n- announces.json: valid_announces array\n- links.json: handshake_vectors array\n- interface_framing.json: hdlc and kiss sections\n- channels.json: envelope_vectors, window_thresholds\n- resources.json: advertisement_vectors\n- resource_transfers.json: transfers array\n- buffer_transfers.json: small_transfer_vectors\n- retry_timers.json: keepalive/retry timing data\n- window_adaptation.json: window growth/shrink data\n- path_requests.json / path_expiration.json: path table test data\n- multi_hop_routing.json: routing test data\n- requests.json: request/response format data\n\nAll hex-encoded fields should be decoded with hex::decode(). Test pattern: load via include_str!, deserialize, iterate vectors, assert.\n\nAcceptance: Test vector structs compile and can successfully deserialize all 17 JSON files.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:21.982222473Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:28:57.884733118Z","closed_at":"2026-02-12T18:28:57.884733118Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.3","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:21.982767805Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-97m.3","depends_on_id":"Rusticulum-97m.1","type":"blocks","created_at":"2026-02-08T03:16:34.934704118Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m.4","title":"Configure CI quality gates","description":"Set up CI configuration (GitHub Actions or similar) with the following quality gates:\n\n- cargo fmt --check (formatting)\n- cargo clippy -- -D warnings (linting, deny warnings)\n- cargo test (all tests pass)\n- cargo test with --no-default-features for crypto and core crates (no_std compat)\n- cargo doc --no-deps (documentation builds)\n\nAlso configure:\n- Rust toolchain pinning (stable channel)\n- Caching for faster builds\n- Test coverage reporting (cargo-tarpaulin or similar)\n\nAcceptance: CI pipeline runs all checks and reports pass/fail status.","status":"closed","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:26.187881257Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:02:21.889730697Z","closed_at":"2026-02-12T18:02:21.889730697Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.4","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:26.188490062Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-97m.4","depends_on_id":"Rusticulum-97m.1","type":"blocks","created_at":"2026-02-08T03:16:34.953267291Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-97m.5","title":"Set up tracing infrastructure","description":"Configure tracing infrastructure across all crates. Add tracing as a workspace dependency. Set up:\n\n- tracing subscriber configuration in reticulum-node (the top-level orchestrator)\n- Structured logging with appropriate log levels:\n  - ERROR: Unrecoverable failures, protocol violations\n  - WARN: Recoverable errors, unexpected but handled conditions\n  - INFO: High-level protocol events (link established, announce received, resource transfer complete)\n  - DEBUG: Detailed protocol state changes, packet parsing, crypto operations\n  - TRACE: Wire-level data, raw bytes, individual state machine transitions\n- Use tracing::instrument on key functions\n- Span-based context for operations (per-link, per-resource, per-interface)\n- In no_std crates (crypto, core): use tracing behind a feature flag so it compiles without std\n\nAcceptance: Tracing compiles in all crates, log output is structured and filterable by level.","status":"closed","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:16:30.363915011Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T18:01:49.345993377Z","closed_at":"2026-02-12T18:01:49.345993377Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-97m.5","depends_on_id":"Rusticulum-97m","type":"parent-child","created_at":"2026-02-08T03:16:30.364415182Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-97m.5","depends_on_id":"Rusticulum-97m.1","type":"blocks","created_at":"2026-02-08T03:16:34.97221265Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha","title":"Core Types and Wire Formats (reticulum-core)","description":"Implement protocol types, constants, identity/addressing, packet wire formats, framing (HDLC/KISS), and announce construction/validation. All types use strong newtypes to prevent mixing raw byte arrays. Wire format tests must be bidirectional (parse raw → verify fields, serialize fields → compare bytes). Depends on reticulum-crypto. Should support optional no_std with alloc.","status":"closed","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:45.333562842Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.431517458Z","closed_at":"2026-02-12T19:48:29.431517458Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha","depends_on_id":"Rusticulum-sed","type":"blocks","created_at":"2026-02-08T03:15:08.618941216Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.1","title":"Implement protocol constants module","description":"Define all protocol constants in a dedicated constants module:\n\npub const MTU: usize = 500;                    // Maximum transmission unit\npub const HEADER_MINSIZE: usize = 19;          // HEADER_1 size\npub const HEADER_MAXSIZE: usize = 37;          // HEADER_2 size  \npub const MDU: usize = 462;                    // Max data unit: MTU - HEADER_MAXSIZE - 1\npub const TRUNCATED_HASHLENGTH: usize = 16;    // Destination/identity hash length\npub const HASHLENGTH: usize = 32;              // Full SHA-256 hash\npub const KEYSIZE: usize = 64;                 // 32 X25519 + 32 Ed25519\npub const SIGLENGTH: usize = 64;              // Ed25519 signature\npub const NAME_HASH_LENGTH: usize = 10;        // Truncated app name hash\npub const TOKEN_OVERHEAD: usize = 48;          // 16 IV + 32 HMAC\npub const ECPUBSIZE: usize = 64;               // Ephemeral pub in link request\n\nAlso define enums/constants for:\n- HEADER_1 = 0, HEADER_2 = 1 (header types)\n- BROADCAST = 0, TRANSPORT = 1 (transport types)\n- Destination types: SINGLE=0b00, GROUP=0b01, PLAIN=0b10, LINK=0b11\n- Packet types: DATA=0b00, ANNOUNCE=0b01, LINKREQUEST=0b10, PROOF=0b11\n\nThese should be compile-time constants with appropriate types. Add doc comments explaining each constant's role in the protocol.\n\nAcceptance: Constants module compiles, values match implementation plan Part 1 table.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:25:51.118247306Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.221622934Z","closed_at":"2026-02-12T19:48:29.221622934Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.1","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:25:51.118891383Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.10","title":"Implement Announce construction and validation","description":"Implement announce packet construction and validation:\n\nAnnounce signed_data construction (implementation plan Part 8 point 6):\n  signed_data = dest_hash(16) + public_key(64) + name_hash(10) + random_hash(10) + [ratchet(32)] + [app_data]\n  NOTE: destination_hash is the FIRST field in signed_data but is NOT part of the wire payload!\n\nRandom hash (Part 8 point 7):\n  random_hash = random_bytes(5) + timestamp_bytes(5)  (10 bytes total)\n  timestamp_bytes = current_unix_timestamp as big-endian 5 bytes\n\nAnnounce wire payload (what goes in the packet data field):\n  payload = public_key(64) + name_hash(10) + random_hash(10) + [ratchet(32)] + [app_data] + signature(64)\n\npub struct Announce {\n    pub destination_hash: DestinationHash,\n    pub public_key: PublicKey,\n    pub name_hash: NameHash,\n    pub random_hash: [u8; 10],\n    pub ratchet: Option\u003c[u8; 32]\u003e,\n    pub app_data: Option\u003cVec\u003cu8\u003e\u003e,\n    pub signature: Signature,\n}\n\nimpl Announce {\n    // Construction (for sending)\n    pub fn create(identity: \u0026Identity, destination: \u0026Destination, app_data: Option\u003c\u0026[u8]\u003e, ratchet: Option\u003c\u0026[u8; 32]\u003e) -\u003e Result\u003cSelf, AnnounceError\u003e;\n    // For deterministic testing:\n    pub fn create_deterministic(identity: \u0026Identity, destination: \u0026Destination, app_data: Option\u003c\u0026[u8]\u003e, ratchet: Option\u003c\u0026[u8; 32]\u003e, random_hash: \u0026[u8; 10]) -\u003e Result\u003cSelf, AnnounceError\u003e;\n    \n    // Validation (for receiving)\n    pub fn from_payload(destination_hash: \u0026DestinationHash, payload: \u0026[u8]) -\u003e Result\u003cSelf, AnnounceError\u003e;\n    pub fn validate(\u0026self) -\u003e bool;  // Verify signature against signed_data\n    \n    // Serialization\n    pub fn to_payload(\u0026self) -\u003e Vec\u003cu8\u003e;  // Wire payload (without dest_hash)\n    pub fn signed_data(\u0026self) -\u003e Vec\u003cu8\u003e;  // Full signed data (with dest_hash)\n    \n    // Build full raw packet\n    pub fn to_raw_packet(\u0026self, hops: u8) -\u003e Vec\u003cu8\u003e;\n}\n\nTest against announces.json -\u003e valid_announces:\n- Array of {keypair_index, app_name, aspects, name_hash, destination_hash, random_hash, ratchet (optional), signed_data, signature, announce_payload, flags_byte, raw_packet, packet_hash}\n- For each vector:\n  1. Load identity from keypairs.json[keypair_index]\n  2. Create announce deterministically with known random_hash\n  3. Verify signed_data matches expected\n  4. Verify signature matches expected\n  5. Verify announce_payload matches expected\n  6. Verify raw_packet matches expected (full packet with header)\n  7. Verify packet_hash matches expected\n  8. Parse announce from payload, validate signature\n\nAdd tracing::info! for announce creation, debug! for validation.\n\nProperty tests:\n- Created announce always validates successfully\n- Announce with corrupted signature fails validation\n- Announce payload always contains public_key + name_hash + random_hash + signature\n- Round-trip: from_payload(to_payload(announce)) preserves all fields\n\nAcceptance: All announces.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:38.984227124Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.395905647Z","closed_at":"2026-02-12T19:48:29.395905647Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.10","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:38.984813998Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.10","depends_on_id":"Rusticulum-bha.3","type":"blocks","created_at":"2026-02-08T03:28:32.847325416Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.10","depends_on_id":"Rusticulum-bha.4","type":"blocks","created_at":"2026-02-08T03:28:32.866891233Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.10","depends_on_id":"Rusticulum-bha.7","type":"blocks","created_at":"2026-02-08T03:28:32.886905499Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.11","title":"Implement error types for core crate","description":"Define comprehensive error types using thiserror for the core crate:\n\n#[derive(Debug, thiserror::Error)]\npub enum PacketError {\n    #[error(\"packet too short: {0} bytes, minimum {1}\")]\n    TooShort(usize, usize),\n    #[error(\"invalid header type: {0}\")]\n    InvalidHeaderType(u8),\n    #[error(\"invalid context type: {0:#x}\")]\n    InvalidContextType(u8),\n    #[error(\"invalid destination hash length\")]\n    InvalidDestinationHash,\n    // ... other variants\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum IdentityError {\n    #[error(\"no private key available\")]\n    NoPrivateKey,\n    #[error(\"invalid key length: expected {expected}, got {got}\")]\n    InvalidKeyLength { expected: usize, got: usize },\n    #[error(\"decryption failed\")]\n    DecryptionFailed,\n    #[error(\"signature verification failed\")]\n    SignatureVerificationFailed,\n    // ...\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum FramingError {\n    #[error(\"missing frame delimiter\")]\n    MissingDelimiter,\n    #[error(\"incomplete escape sequence\")]\n    IncompleteEscape,\n    // ...\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum AnnounceError { ... }\n\nAlso define CryptoError in reticulum-crypto crate:\n#[derive(Debug, thiserror::Error)]\npub enum CryptoError {\n    #[error(\"invalid padding\")]\n    InvalidPadding,\n    #[error(\"HMAC verification failed\")]\n    HmacVerificationFailed,\n    #[error(\"ciphertext too short\")]\n    CiphertextTooShort,\n    #[error(\"invalid key length\")]\n    InvalidKeyLength,\n    // ...\n}\n\nAll errors should include enough context for debugging. Use tracing::warn! or error! when errors are created.\n\nAcceptance: All error types compile, provide useful messages, integrate with ? operator.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:48.983964629Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.413592463Z","closed_at":"2026-02-12T19:48:29.413592463Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.11","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:48.984619066Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.2","title":"Implement newtype wrappers for protocol byte arrays","description":"Implement strong newtype wrappers to prevent mixing raw byte arrays. Each type wraps a fixed-size byte array and implements standard traits:\n\nCore hash types:\n- TruncatedHash([u8; 16]) - implements Copy, Clone, Eq, PartialEq, Hash, AsRef\u003c[u8]\u003e, TryFrom\u003c\u0026[u8]\u003e, Display (hex), Debug, serde Serialize/Deserialize\n- FullHash([u8; 32]) - same traits\n- NameHash([u8; 10]) - same traits\n\nProtocol-specific newtypes (wrapping TruncatedHash or FullHash):\n- DestinationHash(TruncatedHash) - 16-byte destination hash\n- IdentityHash(TruncatedHash) - 16-byte identity hash\n- LinkId(TruncatedHash) - 16-byte link identifier\n- PacketHash(FullHash) - 32-byte packet hash\n- Signature([u8; 64]) - Ed25519 signature (SIGLENGTH=64)\n\nKey types:\n- X25519Pub([u8; 32]) - X25519 public key\n- Ed25519Pub([u8; 32]) - Ed25519 public key\n- PublicKey { encryption: X25519Pub, signing: Ed25519Pub } - combined public key (KEYSIZE=64 bytes total)\n\nAll types must implement:\n- TryFrom\u003c\u0026[u8]\u003e with proper length validation and error\n- AsRef\u003c[u8]\u003e for easy byte access\n- Display showing hex encoding (lowercase)\n- Debug showing abbreviated hex (first 4 bytes + '...')\n- serde Serialize/Deserialize (as hex strings)\n- From\u003c[u8; N]\u003e for direct construction from fixed-size arrays\n\nAdd tracing::trace! where appropriate for type conversions.\n\nProperty tests:\n- TryFrom rejects wrong-length slices\n- Round-trip: TryFrom(type.as_ref()) == original\n- Display output is valid hex and correct length\n- Serde round-trip: deserialize(serialize(x)) == x\n\nAcceptance: All newtypes compile with correct trait implementations, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:04.563885038Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.252141439Z","closed_at":"2026-02-12T19:48:29.252141439Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.2","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:04.56442761Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.2","depends_on_id":"Rusticulum-bha.1","type":"blocks","created_at":"2026-02-08T03:28:07.530714901Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.3","title":"Implement Identity struct with key management","description":"Implement the Identity struct supporting both full (private+public) and public-only modes:\n\npub struct Identity { /* private fields */ }\n\nimpl Identity {\n    // Construction\n    pub fn generate() -\u003e Self;  // Generate new random keypair\n    pub fn from_private_bytes(bytes: \u0026[u8; 64]) -\u003e Result\u003cSelf, IdentityError\u003e;  // 32 X25519 prv + 32 Ed25519 prv\n    pub fn from_public_bytes(bytes: \u0026[u8; 64]) -\u003e Result\u003cSelf, IdentityError\u003e;   // 32 X25519 pub + 32 Ed25519 pub\n    \n    // Accessors\n    pub fn hash(\u0026self) -\u003e IdentityHash;  // SHA256(x25519_pub || ed25519_pub)[0:16]\n    pub fn public_key(\u0026self) -\u003e PublicKey;\n    pub fn has_private_key(\u0026self) -\u003e bool;\n    \n    // Crypto operations (require private key)\n    pub fn sign(\u0026self, message: \u0026[u8]) -\u003e Result\u003cSignature, IdentityError\u003e;\n    pub fn verify(\u0026self, signature: \u0026Signature, message: \u0026[u8]) -\u003e bool;  // works with public-only too\n    \n    // Encryption (public key envelope encryption)\n    pub fn encrypt(\u0026self, plaintext: \u0026[u8], ratchet: Option\u003c\u0026[u8; 32]\u003e) -\u003e Result\u003cVec\u003cu8\u003e, IdentityError\u003e;\n    pub fn decrypt(\u0026self, ciphertext: \u0026[u8], ratchets: \u0026[[u8; 32]]) -\u003e Result\u003cVec\u003cu8\u003e, IdentityError\u003e;\n}\n\nIdentity hash computation:\n  identity_hash = SHA256(x25519_pub || ed25519_pub)[0:16]\n\nIdentity encryption (envelope):\n1. Generate ephemeral X25519 keypair\n2. ECDH: shared_secret = ephemeral_prv.exchange(target_pub_or_ratchet)\n3. derived_key = HKDF(length=64, ikm=shared_secret, salt=identity_hash, info=b'')\n4. token = Token(derived_key).encrypt(plaintext)\n5. output = ephemeral_pub(32) || token(48+ bytes)\n\nFor deterministic testing, provide internal method that accepts pre-generated ephemeral key.\n\nTest against keypairs.json:\n- Load each keypair's private_key (64 bytes = x25519_prv || ed25519_prv)\n- Derive public key, verify matches public_key field\n- Compute identity_hash, verify matches identity_hash field\n- Sign/verify using signature_vectors\n\nAdd tracing::info! for key generation, debug! for hash computation and crypto ops.\n\nProperty tests:\n- Generated identity always has private key\n- Public-only identity returns error on sign\n- identity_hash is deterministic from public key\n- encrypt then decrypt round-trips successfully\n- decrypt fails with wrong identity\n\nAcceptance: All keypairs.json identity vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:20.305460347Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.270484951Z","closed_at":"2026-02-12T19:48:29.270484951Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.3","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:20.30603265Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.3","depends_on_id":"Rusticulum-bha.2","type":"blocks","created_at":"2026-02-08T03:28:11.573491199Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.4","title":"Implement Destination hashing","description":"Implement destination hash computation:\n\npub enum DestinationType { Single, Group, Plain, Link }\n\npub struct Destination {\n    identity: Option\u003cIdentityHash\u003e,\n    app_name: String,\n    aspects: Vec\u003cString\u003e,\n    dtype: DestinationType,\n}\n\nimpl Destination {\n    pub fn name_hash(app_name: \u0026str, aspects: \u0026[\u0026str]) -\u003e NameHash;\n    pub fn hash(\u0026self) -\u003e DestinationHash;\n}\n\nHash computation:\n  name_hash = SHA256('app_name.aspect1.aspect2'.encode('utf-8'))[0:10]   (10 bytes, NAME_HASH_LENGTH)\n  destination_hash = SHA256(name_hash || identity_hash)[0:16]             (16 bytes, TRUNCATED_HASHLENGTH)\n\nThe full app name string is constructed by joining app_name and all aspects with '.' separator.\n\nTest against destination_hashes.json -\u003e single_destinations:\n- Array of {app_name, aspects (array of strings), name_hash (hex, 10 bytes), identity_hash (hex), addr_hash_material (hex = name_hash || identity_hash), destination_hash (hex), keypair_index}\n- For each vector:\n  1. Compute name_hash from app_name + aspects, verify matches\n  2. Load identity from keypairs.json[keypair_index], compute identity_hash, verify matches\n  3. Verify addr_hash_material = name_hash || identity_hash\n  4. Compute destination_hash, verify matches\n\nAdd tracing::debug! for destination hash computation showing app name and result.\n\nProperty tests:\n- name_hash is always 10 bytes\n- destination_hash is always 16 bytes\n- Different app names produce different name hashes\n- Same app_name + aspects always produce same name_hash\n\nAcceptance: All destination_hashes.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:29.879022323Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.288476029Z","closed_at":"2026-02-12T19:48:29.288476029Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.4","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:29.879739132Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.4","depends_on_id":"Rusticulum-bha.2","type":"blocks","created_at":"2026-02-08T03:28:15.911721264Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.4","depends_on_id":"Rusticulum-bha.3","type":"blocks","created_at":"2026-02-08T03:28:15.93296796Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.5","title":"Implement packet flags encoding/decoding","description":"Implement PacketFlags - single byte encode/decode for packet header flags:\n\npub struct PacketFlags {\n    pub header_type: HeaderType,       // Bit 7: 0=HEADER_1, 1=HEADER_2\n    pub context_flag: bool,            // Bit 6: context flag\n    pub transport_type: TransportType, // Bit 5: 0=BROADCAST, 1=TRANSPORT\n    pub destination_type: DestinationType, // Bits 4-3\n    pub packet_type: PacketType,       // Bits 1-0 (note: bits 1-0, NOT 2-1)\n}\n\nBit layout of flags byte:\n  Bit 7:    header_type   (0=HEADER_1, 1=HEADER_2)\n  Bit 6:    context_flag  (0=unset, 1=set)\n  Bit 5:    transport_type (0=BROADCAST, 1=TRANSPORT)\n  Bits 4-3: destination_type (00=SINGLE, 01=GROUP, 10=PLAIN, 11=LINK)\n  Bits 1-0: packet_type (00=DATA, 01=ANNOUNCE, 10=LINKREQUEST, 11=PROOF)\n\nNote: Bit 2 is unused/reserved (always 0).\n\nimpl PacketFlags {\n    pub fn from_byte(byte: u8) -\u003e Self;\n    pub fn to_byte(\u0026self) -\u003e u8;\n}\n\nTest against packet_headers.json -\u003e header_vectors:\n- Array of {flags_byte (int), header_type, packet_type, destination_type, transport_type, context_flag, ...}\n- For each vector: decode flags_byte, verify all field values match\n- Re-encode to byte, verify matches original flags_byte\n\nAlso test against packet_headers.json -\u003e flag_byte_layout, packet_type_values, context_type_values for enum value correctness.\n\nAdd tracing::trace! for flags parsing.\n\nProperty tests:\n- Round-trip: from_byte(to_byte(flags)) == flags\n- to_byte produces values 0-255\n- Bit 2 is always 0\n\nAcceptance: All packet_headers.json vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:40.618140718Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.306498799Z","closed_at":"2026-02-12T19:48:29.306498799Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.5","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:40.618692791Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.5","depends_on_id":"Rusticulum-bha.1","type":"blocks","created_at":"2026-02-08T03:28:23.902058349Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.6","title":"Implement ContextType enum","description":"Implement the ContextType enum representing all packet context values:\n\npub enum ContextType {\n    None = 0x00,\n    Resource = 0x01,\n    ResourceAdv = 0x02,\n    ResourceReq = 0x03,\n    ResourceHmu = 0x04,\n    ResourceIcl = 0x05,\n    ResourceRcl = 0x06,\n    Channel = 0x07,\n    Keepalive = 0xFA,\n    LinkIdentify = 0xFB,\n    LinkClose = 0xFC,\n    LinkProof = 0xFD,\n    LRProof = 0xFE,\n    LRRtt = 0xFF,\n    // Add any others from packet_headers.json context_type_values\n}\n\nimpl ContextType {\n    pub fn from_byte(byte: u8) -\u003e Result\u003cSelf, PacketError\u003e;\n    pub fn to_byte(\u0026self) -\u003e u8;\n}\n\nTest against packet_headers.json -\u003e context_type_values to verify all context types are defined with correct numeric values.\n\nAcceptance: All context types from test vectors are represented, bidirectional conversion works.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:26:47.870063166Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.324762078Z","closed_at":"2026-02-12T19:48:29.324762078Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.6","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:26:47.870813387Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.6","depends_on_id":"Rusticulum-bha.1","type":"blocks","created_at":"2026-02-08T03:28:23.921738991Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.7","title":"Implement RawPacket parsing and serialization","description":"Implement zero-copy packet parsing and serialization:\n\npub struct RawPacket\u003c'a\u003e {\n    pub flags: PacketFlags,\n    pub hops: u8,\n    pub transport_id: Option\u003cDestinationHash\u003e,  // Present only for HEADER_2\n    pub destination: DestinationHash,\n    pub context: ContextType,\n    pub data: \u0026'a [u8],\n}\n\nHEADER_1 layout (19+ bytes): flags(1) + hops(1) + dest_hash(16) + context(1) + data(...)\nHEADER_2 layout (35+ bytes): flags(1) + hops(1) + transport_id(16) + dest_hash(16) + context(1) + data(...)\n\nimpl\u003c'a\u003e RawPacket\u003c'a\u003e {\n    pub fn parse(raw: \u0026'a [u8]) -\u003e Result\u003cSelf, PacketError\u003e;\n    pub fn serialize(\u0026self) -\u003e Vec\u003cu8\u003e;\n    pub fn hashable_part(\u0026self) -\u003e Vec\u003cu8\u003e;\n    pub fn packet_hash(\u0026self) -\u003e PacketHash;\n}\n\nCRITICAL - hashable_part computation (implementation plan Part 8 point 4):\n- Flags byte is masked to (flags \u0026 0x0F) - keep only destination_type and packet_type (lower 4 bits)\n- Hops byte is EXCLUDED\n- For HEADER_2: transport_id is EXCLUDED\n- Result: masked_flags(1) + dest_hash(16) + context(1) + data(...)\n\npacket_hash = SHA256(hashable_part) (full 32 bytes)\n\nParse must validate:\n- Minimum length (HEADER_MINSIZE=19 for HEADER_1, HEADER_MAXSIZE=37 for HEADER_2)  \n- Header type determines whether transport_id is present\n\nTest against packets_data.json (or similar packet test vector file):\n- Parse raw packet bytes, verify all fields match expected\n- Serialize from fields, verify matches original raw bytes (bidirectional!)\n- Compute hashable_part and packet_hash, verify against expected\n\nAdd tracing::debug! for packet parsing (destination, type, data length), trace! for raw bytes.\n\nProperty tests:\n- parse(serialize(packet)) == packet (round-trip)\n- hashable_part always has masked flags (upper 4 bits = 0 except for dest_type bits)\n- hashable_part never contains hops byte\n- HEADER_1 packets serialize to \u003e= 19 bytes\n- HEADER_2 packets serialize to \u003e= 35 bytes\n\nAcceptance: All packet test vectors pass bidirectionally, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:01.674582246Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.342572438Z","closed_at":"2026-02-12T19:48:29.342572438Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.7","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:01.675211462Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.7","depends_on_id":"Rusticulum-bha.2","type":"blocks","created_at":"2026-02-08T03:28:28.150827077Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.7","depends_on_id":"Rusticulum-bha.5","type":"blocks","created_at":"2026-02-08T03:28:28.171186447Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-bha.7","depends_on_id":"Rusticulum-bha.6","type":"blocks","created_at":"2026-02-08T03:28:28.190693062Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.8","title":"Implement HDLC framing","description":"Implement HDLC byte-stuffing framing for interface communication:\n\nConstants:\n  FLAG: u8 = 0x7E\n  ESC: u8 = 0x7D\n  ESC_MASK: u8 = 0x20\n\npub fn hdlc_frame(data: \u0026[u8]) -\u003e Vec\u003cu8\u003e;\npub fn hdlc_unframe(framed: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, FramingError\u003e;\n\nFrame algorithm:\n1. Start with FLAG byte (0x7E)\n2. For each data byte:\n   - If byte == ESC (0x7D): output ESC, then (byte XOR ESC_MASK) = 0x5D\n   - If byte == FLAG (0x7E): output ESC, then (byte XOR ESC_MASK) = 0x5E\n   - Otherwise: output byte as-is\n3. End with FLAG byte (0x7E)\n\nCRITICAL escape order (implementation plan Part 8 point 5):\n  ESC bytes (0x7D) MUST be escaped BEFORE FLAG bytes (0x7E).\n  Reversing this order corrupts data containing ESC bytes.\n\nUnframe algorithm:\n1. Strip leading/trailing FLAG bytes\n2. Process escape sequences: ESC followed by byte -\u003e (byte XOR ESC_MASK)\n3. Return unescaped data\n\nTest against interface_framing.json -\u003e hdlc -\u003e vectors:\n- Array of {raw (hex), framed (hex), description}\n- Frame raw data, verify matches framed\n- Unframe framed data, verify matches raw\n\nAdd tracing::trace! for frame/unframe showing data lengths.\n\nProperty tests:\n- Round-trip: unframe(frame(data)) == data for any input\n- Framed output always starts and ends with FLAG (0x7E)\n- Framed output never contains unescaped FLAG or ESC bytes in the middle\n- Frame of empty data is just FLAG + FLAG\n- Data containing FLAG bytes produces longer output than data without\n\nEdge cases: empty data, data that is all FLAG bytes, data that is all ESC bytes, data with ESC followed by FLAG.\n\nAcceptance: All interface_framing.json hdlc vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:14.115288039Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.360422381Z","closed_at":"2026-02-12T19:48:29.360422381Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.8","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:14.115827891Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-bha.9","title":"Implement KISS framing","description":"Implement KISS byte-stuffing framing:\n\nConstants:\n  FEND: u8 = 0xC0\n  FESC: u8 = 0xDB\n  TFEND: u8 = 0xDC\n  TFESC: u8 = 0xDD\n\npub fn kiss_frame(data: \u0026[u8]) -\u003e Vec\u003cu8\u003e;\npub fn kiss_unframe(framed: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, FramingError\u003e;\n\nFrame algorithm:\n1. Start with FEND byte (0xC0)\n2. For each data byte:\n   - If byte == FEND (0xC0): output FESC + TFEND (0xDB, 0xDC)\n   - If byte == FESC (0xDB): output FESC + TFESC (0xDB, 0xDD)\n   - Otherwise: output byte as-is\n3. End with FEND byte (0xC0)\n\nUnframe: reverse the process, strip FEND delimiters, decode escape sequences.\n\nTest against interface_framing.json -\u003e kiss -\u003e vectors (if present):\n- Same pattern as HDLC: frame raw, compare with expected; unframe framed, compare with raw\n\nAdd tracing::trace! for frame/unframe showing data lengths.\n\nProperty tests:\n- Round-trip: unframe(frame(data)) == data\n- Framed output always starts and ends with FEND\n- No unescaped FEND or FESC in middle of framed output\n\nAcceptance: All KISS vectors pass (if present), proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:27:21.449172904Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:48:29.377962701Z","closed_at":"2026-02-12T19:48:29.377962701Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-bha.9","depends_on_id":"Rusticulum-bha","type":"parent-child","created_at":"2026-02-08T03:27:21.449734187Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u","title":"Protocol State Machines (reticulum-protocol)","description":"Implement all protocol state machines: Link handshake (type-state pattern: Pending→Handshake→Active→Closed), MTU signalling, keepalive, Channel (envelopes, sequencing, window control), Resource (advertisement, windowing, hashmap, transfer, segmentation), Buffer (stream protocol, compression), and Request/Response. State machines produce Vec\u003cu8\u003e actions, never perform I/O directly. Depends on reticulum-core.","status":"open","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:49.049339967Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:14:49.049339967Z","dependencies":[{"issue_id":"Rusticulum-c7u","depends_on_id":"Rusticulum-bha","type":"blocks","created_at":"2026-02-08T03:15:08.637876783Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.1","title":"Implement Link state types and type-state pattern","description":"Implement the Link state machine using Rust's type-state pattern. Define separate types for each link state:\n\npub struct LinkPending {\n    // Ephemeral X25519 keypair (initiator) or received pub keys (responder)\n    // Ephemeral Ed25519 keypair\n    // Target destination\n    // Request timestamp\n}\n\npub struct LinkHandshake {\n    // Derived key (64 bytes)\n    // Token instance\n    // Peer's signing public key\n    // Link ID\n}\n\npub struct LinkActive {\n    // Token for encrypt/decrypt\n    // RTT measurement\n    // MDU (effective max data unit)\n    // Keepalive interval\n    // Last activity timestamp\n}\n\npub struct LinkClosed {\n    // Close reason\n    // Final statistics\n}\n\nFor runtime use where the state needs to be dynamic, provide:\npub enum LinkState {\n    Pending(LinkPending),\n    Handshake(LinkHandshake),\n    Active(LinkActive),\n    Closed(LinkClosed),\n}\n\nEach state type contains only the data relevant to that state. Transitions consume the old state and produce the new state (move semantics), ensuring invalid state transitions are compile-time errors.\n\nAdd tracing::info! for state transitions, debug! for state details.\n\nAcceptance: All state types compile, transitions are type-safe, LinkState enum wraps all states.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:08.807288044Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T20:08:03.055748683Z","closed_at":"2026-02-12T20:08:03.055748683Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.1","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:08.807997763Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.10","title":"Implement Resource hashmap and part tracking","description":"Implement the resource hashmap for tracking transfer parts:\n\nParts use 4-byte truncated hashes:\n  part_hash = SHA256(part_data)[0:4]\n\nHASHMAP_MAX_LEN = 74\n\npub struct ResourceHashmap {\n    parts: Vec\u003c[u8; 4]\u003e,  // 4-byte truncated hashes\n}\n\nimpl ResourceHashmap {\n    pub fn new() -\u003e Self;\n    pub fn add_part(\u0026mut self, data: \u0026[u8]) -\u003e [u8; 4];  // Returns 4-byte hash\n    pub fn to_bytes(\u0026self) -\u003e Vec\u003cu8\u003e;  // Concatenated 4-byte hashes (max 74 entries = 296 bytes)\n    pub fn from_bytes(data: \u0026[u8]) -\u003e Result\u003cSelf, ResourceError\u003e;\n    pub fn verify_part(\u0026self, index: usize, data: \u0026[u8]) -\u003e bool;\n    pub fn len(\u0026self) -\u003e usize;\n}\n\nHashmap segments: when parts exceed HASHMAP_MAX_LEN, split into multiple hashmap messages.\n\nTest against resource_transfers.json:\n- Compute 4-byte part hashes, verify against expected\n- Build hashmap segments, verify against expected\n\nAdd tracing::trace! for part hash computation.\n\nProperty tests:\n- Part hash is always 4 bytes\n- Hashmap bytes length == 4 * num_parts\n- Parts exceeding HASHMAP_MAX_LEN are correctly segmented\n- verify_part returns true for correct data, false for corrupted\n\nAcceptance: All resource_transfers.json hashmap vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:47.993124884Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:32:47.993124884Z","dependencies":[{"issue_id":"Rusticulum-c7u.10","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:47.993746859Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.11","title":"Implement Resource transfer simulation","description":"Implement full resource transfer lifecycle:\n\nStates: Queued -\u003e Advertised -\u003e Transferring -\u003e AwaitingProof -\u003e Complete\n\npub enum ResourceState {\n    Queued,\n    Advertised { advertisement: ResourceAdvertisement },\n    Transferring { window: WindowState, parts_sent: usize, parts_total: usize },\n    AwaitingProof { resource_hash: FullHash },\n    Complete,\n    Failed(ResourceError),\n}\n\nResource proof:\n  proof = SHA256(data || resource_hash)\n\nSegmentation for large resources:\n  MAX_EFFICIENT_SIZE = 1,048,575 bytes\n  Resources larger than this are split into segments\n\nPart encryption: each part is encrypted with the link's Token before transmission.\n\nTest against resource_transfers.json -\u003e transfers:\n- Array of {data_hex, advertisement, parts: [...], proof, derived_key}\n- For each transfer:\n  1. Create resource from data\n  2. Generate advertisement, verify matches\n  3. Split into parts, encrypt each with Token(derived_key)\n  4. Verify each encrypted part matches expected\n  5. Reassemble parts, decrypt, verify matches original data\n  6. Compute proof, verify matches expected\n\nAdd tracing::info! for transfer lifecycle events, debug! for part details.\n\nProperty tests:\n- All parts reassemble to original data\n- Proof is deterministic from data + resource_hash\n- Encrypted parts can be decrypted with correct key\n- Part count matches expected for given data size\n\nAcceptance: All resource_transfers.json transfer vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:33:00.557404493Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:33:00.557404493Z","dependencies":[{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:33:00.557951286Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u.8","type":"blocks","created_at":"2026-02-08T03:34:06.352908505Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u.9","type":"blocks","created_at":"2026-02-08T03:34:06.373900302Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u.10","type":"blocks","created_at":"2026-02-08T03:34:06.394714081Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.11","depends_on_id":"Rusticulum-c7u.5","type":"blocks","created_at":"2026-02-08T03:34:06.415090683Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.12","title":"Implement Buffer stream protocol","description":"Implement the Buffer stream protocol for streaming data over channels:\n\nStream header (2 bytes, big-endian):\n  Bit 15: EOF flag (1 = this is the last chunk)\n  Bit 14: compressed flag (1 = data is bz2 compressed)\n  Bits 13-0: stream_id (14-bit value, 0-16383)\n\npub struct StreamHeader {\n    pub is_eof: bool,\n    pub is_compressed: bool,\n    pub stream_id: u16,  // 14-bit\n}\n\nimpl StreamHeader {\n    pub fn encode(\u0026self) -\u003e [u8; 2];\n    pub fn decode(bytes: \u0026[u8; 2]) -\u003e Self;\n}\n\nBuffer message construction:\n  message = stream_header(2) + data_chunk(...)\n\nCompression: attempt bz2 compression with 4 retry attempts at decreasing sizes:\n  Try sizes: [full, 3/4, 1/2, 1/4] of the data\n  Use compressed version only if it is smaller than uncompressed\n\npub struct BufferMessage {\n    pub header: StreamHeader,\n    pub data: Vec\u003cu8\u003e,\n}\n\nimpl BufferMessage {\n    pub fn pack(\u0026self) -\u003e Vec\u003cu8\u003e;  // stream_header + data\n    pub fn unpack(bytes: \u0026[u8]) -\u003e Result\u003cSelf, BufferError\u003e;\n}\n\nTest against buffer_transfers.json -\u003e small_transfer_vectors:\n- Array of {data (hex), messages: [{chunk_hex, stream_packed_hex, envelope_packed_hex, compressed (bool), is_eof (bool), sequence (int), offset (int)}]}\n- For each transfer, verify:\n  1. Stream header encoding matches expected\n  2. Chunk data matches expected\n  3. Compression flag matches expected\n  4. EOF flag matches expected\n\nAdd tracing::debug! for buffer operations, trace! for compression attempts.\n\nProperty tests:\n- Stream header round-trip: decode(encode(header)) preserves all fields\n- stream_id fits in 14 bits (0-16383)\n- Compressed data decompresses to original (when compression is used)\n- EOF is set on the last message only\n\nAcceptance: All buffer_transfers.json vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:33:12.964546843Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:33:12.964546843Z","dependencies":[{"issue_id":"Rusticulum-c7u.12","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:33:12.965163408Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.12","depends_on_id":"Rusticulum-c7u.6","type":"blocks","created_at":"2026-02-08T03:34:10.586250684Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.13","title":"Implement Request/Response protocol","description":"Implement the Request/Response RPC-style protocol over links:\n\nRequest format (msgpack): [timestamp, path_hash, data]\nResponse format (msgpack): [request_id, data]\n\npub struct Request {\n    pub timestamp: f64,      // Unix timestamp\n    pub path_hash: Vec\u003cu8\u003e,  // Hash identifying the request path/endpoint\n    pub data: Vec\u003cu8\u003e,       // Request payload (msgpack-encoded)\n}\n\npub struct Response {\n    pub request_id: Vec\u003cu8\u003e,  // Links back to original request\n    pub data: Vec\u003cu8\u003e,        // Response payload\n}\n\nimpl Request {\n    pub fn to_msgpack(\u0026self) -\u003e Vec\u003cu8\u003e;\n    pub fn from_msgpack(data: \u0026[u8]) -\u003e Result\u003cSelf, RequestError\u003e;\n}\n\nimpl Response {\n    pub fn to_msgpack(\u0026self) -\u003e Vec\u003cu8\u003e;\n    pub fn from_msgpack(data: \u0026[u8]) -\u003e Result\u003cSelf, RequestError\u003e;\n}\n\nTest against requests.json:\n- Request/response msgpack encoding/decoding\n- Round-trip serialization\n\nAdd tracing::debug! for request/response operations.\n\nProperty tests:\n- Round-trip: from_msgpack(to_msgpack(request)) preserves fields\n- Timestamp is preserved with float precision\n\nAcceptance: All requests.json vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:33:20.416572532Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:33:20.416572532Z","dependencies":[{"issue_id":"Rusticulum-c7u.13","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:33:20.417124605Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.14","title":"Implement protocol error types","description":"Define error types for the protocol crate using thiserror:\n\n#[derive(Debug, thiserror::Error)]\npub enum LinkError {\n    #[error(\"handshake failed: {0}\")]\n    HandshakeFailed(String),\n    #[error(\"invalid proof: signature verification failed\")]\n    InvalidProof,\n    #[error(\"link not active\")]\n    NotActive,\n    #[error(\"encryption failed: {0}\")]\n    EncryptionFailed(#[from] CryptoError),\n    #[error(\"invalid state transition from {from} to {to}\")]\n    InvalidTransition { from: \u0026'static str, to: \u0026'static str },\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ChannelError { ... }\n\n#[derive(Debug, thiserror::Error)]\npub enum ResourceError { ... }\n\n#[derive(Debug, thiserror::Error)]\npub enum BufferError { ... }\n\n#[derive(Debug, thiserror::Error)]\npub enum RequestError { ... }\n\nAll errors should chain properly with #[from] for underlying crypto/packet errors.\n\nAcceptance: All error types compile, provide useful messages, support error chaining.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:33:27.908900412Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T20:08:03.076702382Z","closed_at":"2026-02-12T20:08:03.076702382Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-c7u.14","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:33:27.909427264Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.2","title":"Implement Link handshake initiator and responder","description":"Implement the 3-packet link handshake protocol:\n\nINITIATOR                                    RESPONDER\n    |                                            |\n    |-- LINKREQUEST [eph_x25519(32) +            |\n    |   eph_ed25519(32) + mtu_signal(3?)] ----\u003e |\n    |                                            |\n    |   link_id = SHA256(hashable_part)[0:16]    |\n    |   (strip mtu signalling from hashable)     |\n    |                                            |\n    | \u003c---- LRPROOF [signature(64) +             |\n    |        resp_x25519(32) + mtu_signal(3?)]   |\n    |                                            |\n    |   Both sides: ECDH -\u003e HKDF(64, shared,     |\n    |     salt=link_id) -\u003e Token(derived_key)    |\n    |                                            |\n    |-- LRRTT [Token.encrypt(msgpack(rtt))] ---\u003e |\n    |                                            |\n    |         === LINK ACTIVE ===                |\n\nInitiator side:\nimpl LinkPending {\n    pub fn new_initiator(destination: \u0026Destination) -\u003e (Self, Vec\u003cu8\u003e);  // returns LINKREQUEST data\n    // Deterministic version for testing:\n    pub fn new_initiator_deterministic(\n        destination: \u0026Destination,\n        eph_x25519_prv: \u0026[u8; 32],\n        eph_ed25519_prv: \u0026[u8; 32],\n    ) -\u003e (Self, Vec\u003cu8\u003e);\n    \n    pub fn receive_proof(self, proof_data: \u0026[u8], responder_identity: \u0026Identity)\n        -\u003e Result\u003c(LinkActive, Vec\u003cu8\u003e), LinkError\u003e;  // returns (active_link, LRRTT_data)\n}\n\nResponder side:\nimpl LinkPending {\n    pub fn new_responder(identity: \u0026Identity, link_request_data: \u0026[u8], destination: \u0026Destination)\n        -\u003e Result\u003c(LinkHandshake, Vec\u003cu8\u003e), LinkError\u003e;  // returns (handshake, LRPROOF_data)\n}\n\nimpl LinkHandshake {\n    pub fn receive_rtt(self, encrypted_rtt: \u0026[u8]) -\u003e Result\u003cLinkActive, LinkError\u003e;\n}\n\nKey derivation:\n1. shared_secret = initiator_eph_x25519.dh(responder_x25519_pub) [or vice versa]\n2. derived_key = HKDF(length=64, ikm=shared_secret, salt=link_id, info=b'')\n3. token = Token(derived_key)\n\nCRITICAL - Link ID computation (Part 8 point 3):\n- link_id = SHA256(hashable_part_of_LINKREQUEST)[0:16]\n- The hashable part only includes up to ECPUBSIZE (64) bytes of data\n- MTU signalling bytes must be STRIPPED before hashing\n\nLRPROOF data:\n- signature(64) = responder signs the link_request_data with Ed25519\n- + responder_x25519_pub(32) [ephemeral or static depending on implementation]\n- + optional mtu_signal(3)\n\nLRRTT data:\n- Token.encrypt(msgpack(rtt_measurement))\n\nTest against links.json -\u003e handshake_vectors:\n- Load initiator/responder keypairs\n- Create initiator with known ephemeral keys\n- Verify LINKREQUEST data matches expected\n- Verify link_id matches expected\n- Process LRPROOF, verify derived_key matches expected\n- Full handshake round-trip\n\nAdd tracing::info! for handshake milestones, debug! for key material (never log private keys at info level!).\n\nProperty tests:\n- Handshake between two random identities always succeeds\n- derived_key is always 64 bytes\n- link_id is always 16 bytes\n- Active link can encrypt/decrypt round-trip\n\nAcceptance: All links.json handshake vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:31.760131438Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:31:31.760131438Z","dependencies":[{"issue_id":"Rusticulum-c7u.2","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:31.760740793Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.2","depends_on_id":"Rusticulum-c7u.1","type":"blocks","created_at":"2026-02-08T03:33:48.403869667Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.2","depends_on_id":"Rusticulum-c7u.3","type":"blocks","created_at":"2026-02-08T03:33:48.424615474Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.3","title":"Implement MTU signalling encode/decode","description":"Implement MTU signalling that can be appended to link request/proof packets:\n\nMTU signalling encoding (Part 8 point 9):\n  3 bytes = big-endian 32-bit integer with first byte stripped\n  value = (mtu \u0026 0x1FFFFF) + (((mode \u003c\u003c 5) \u0026 0xE0) \u003c\u003c 16)\n  The mode occupies the top 3 bits of the first byte (of the 3-byte encoding)\n  The MTU occupies the lower 21 bits\n\npub struct MtuSignal {\n    pub mtu: u32,    // 21-bit MTU value (max 2,097,151)\n    pub mode: u8,    // 3-bit mode (0-7)\n}\n\nimpl MtuSignal {\n    pub fn encode(\u0026self) -\u003e [u8; 3];\n    pub fn decode(bytes: \u0026[u8; 3]) -\u003e Self;\n}\n\nTest against links.json -\u003e mtu_signalling (if present):\n- Encode known MTU/mode values, verify 3-byte output matches\n- Decode known 3-byte values, verify MTU and mode match\n\nAdd tracing::trace! for MTU signalling encode/decode.\n\nProperty tests:\n- Round-trip: decode(encode(signal)) == signal (for valid MTU/mode ranges)\n- MTU values up to 0x1FFFFF encode correctly\n- Mode values 0-7 encode correctly\n- Encoded output is always exactly 3 bytes\n\nAcceptance: All MTU signalling vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:42.236920422Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:31:42.236920422Z","dependencies":[{"issue_id":"Rusticulum-c7u.3","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:42.237471525Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.4","title":"Implement Link keepalive interval calculation","description":"Implement keepalive interval calculation based on RTT:\n\nkeepalive_interval = max(min(rtt * 360/1.75, 360), 5)\n\nWhere:\n- rtt is the round-trip time in seconds\n- Minimum interval is 5 seconds\n- Maximum interval is 360 seconds (6 minutes)\n- Scale factor is 360/1.75 = ~205.7\n\npub fn keepalive_interval(rtt_seconds: f64) -\u003e f64;\n\nAlso implement stale link detection:\npub fn is_stale(last_activity: Duration, keepalive: Duration, factor: f64) -\u003e bool;\n\nimpl LinkActive {\n    pub fn keepalive_interval(\u0026self) -\u003e Duration;\n    pub fn should_send_keepalive(\u0026self, elapsed_since_last: Duration) -\u003e bool;\n    pub fn is_stale(\u0026self, elapsed_since_last: Duration) -\u003e bool;\n}\n\nTest against retry_timers.json:\n- Array of RTT values and expected keepalive intervals\n- Verify computed interval matches expected for each\n\nAdd tracing::debug! for keepalive calculations.\n\nProperty tests:\n- Interval is always \u003e= 5.0 seconds\n- Interval is always \u003c= 360.0 seconds\n- Higher RTT produces higher or equal interval\n- Zero RTT produces minimum interval (5 seconds)\n\nAcceptance: All retry_timers.json vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:50.595703394Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:31:50.595703394Z","dependencies":[{"issue_id":"Rusticulum-c7u.4","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:50.596225936Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.4","depends_on_id":"Rusticulum-c7u.1","type":"blocks","created_at":"2026-02-08T03:33:52.514805608Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.5","title":"Implement Link encryption/decryption for active links","description":"Implement encrypt/decrypt operations on active links using the Token derived during handshake:\n\nimpl LinkActive {\n    pub fn encrypt(\u0026self, plaintext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, LinkError\u003e;\n    pub fn decrypt(\u0026self, ciphertext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, LinkError\u003e;\n    pub fn derived_key(\u0026self) -\u003e \u0026[u8; 64];  // for testing\n    pub fn mdu(\u0026self) -\u003e usize;  // effective max data unit for this link\n}\n\nThe Token instance is created from the 64-byte derived_key during handshake completion. All subsequent link traffic uses this Token for encryption/decryption.\n\nMDU calculation:\n  mdu = min(initiator_mdu, responder_mdu) - TOKEN_OVERHEAD\n  where TOKEN_OVERHEAD = 48 (16 IV + 32 HMAC)\n\nAdd tracing::trace! for encrypt/decrypt showing data lengths.\n\nProperty tests:\n- decrypt(encrypt(data)) == data for any data\n- Encrypted output is always longer than plaintext by exactly TOKEN_OVERHEAD + padding\n- Decrypt fails with wrong Token\n- Decrypt fails with corrupted ciphertext\n\nAcceptance: Encryption/decryption works with handshake-derived keys, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:31:59.059620408Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:31:59.059620408Z","dependencies":[{"issue_id":"Rusticulum-c7u.5","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:31:59.060269965Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.5","depends_on_id":"Rusticulum-c7u.2","type":"blocks","created_at":"2026-02-08T03:33:56.347174385Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.6","title":"Implement Channel envelope packing/unpacking","description":"Implement the 6-byte Channel envelope header:\n\npub struct Envelope {\n    pub msg_type: u16,\n    pub sequence: u16,\n    pub payload: Vec\u003cu8\u003e,\n}\n\nimpl Envelope {\n    pub const OVERHEAD: usize = 6;  // 2 + 2 + 2 bytes\n    \n    pub fn pack(\u0026self) -\u003e Vec\u003cu8\u003e;       // 6-byte header + payload\n    pub fn unpack(data: \u0026[u8]) -\u003e Result\u003cSelf, ChannelError\u003e;  // parse 6-byte header + payload\n}\n\nHeader format (all big-endian):\n  msg_type(2 bytes) + sequence(2 bytes) + length(2 bytes) + payload(length bytes)\n\nTest against channels.json -\u003e envelope_vectors:\n- Array of {msg_type (int), sequence (int), data (hex), packed_hex (hex)}\n- For each vector:\n  1. Pack msg_type + sequence + data, verify matches packed_hex\n  2. Unpack packed_hex, verify msg_type, sequence, and data match\n\nAdd tracing::trace! for envelope pack/unpack.\n\nProperty tests:\n- Round-trip: unpack(pack(envelope)) preserves all fields\n- Pack output length == 6 + payload.len()\n- Unpack rejects data shorter than 6 bytes\n- msg_type and sequence preserve full u16 range\n\nAcceptance: All channels.json envelope vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:09.19325114Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:32:09.19325114Z","dependencies":[{"issue_id":"Rusticulum-c7u.6","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:09.193779352Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.7","title":"Implement Channel sequencing and window control","description":"Implement sequence tracking and window-based flow control for channels:\n\npub struct ChannelState {\n    next_sequence: u16,       // Next sequence number to use (wraps at 0xFFFF)\n    expected_sequence: u16,   // Next expected incoming sequence\n    window_size: usize,       // Current window size\n    max_window: usize,        // Maximum window size\n    min_window: usize,        // Minimum window size\n}\n\nimpl ChannelState {\n    pub fn new() -\u003e Self;\n    pub fn next_sequence(\u0026mut self) -\u003e u16;  // Returns current, increments (wraps at 0xFFFF → 0)\n    pub fn is_in_window(\u0026self, sequence: u16) -\u003e bool;\n    pub fn acknowledge(\u0026mut self, sequence: u16);\n    pub fn window_adapt_success(\u0026mut self);    // Increase window\n    pub fn window_adapt_timeout(\u0026mut self);    // Decrease window\n}\n\nSequence wrapping: when sequence reaches 0xFFFF, it wraps to 0x0000.\n\nTest against channels.json:\n- Sequence wrapping behavior\n- Window adaptation under various conditions\n- window_thresholds data\n\nAdd tracing::debug! for sequence tracking and window changes.\n\nProperty tests:\n- Sequence always wraps correctly at 0xFFFF\n- Window size stays within min..=max bounds\n- Successive next_sequence calls produce incrementing values (with wrap)\n\nAcceptance: All channels.json sequencing/window vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:18.656123549Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:32:18.656123549Z","dependencies":[{"issue_id":"Rusticulum-c7u.7","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:18.656677241Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-c7u.7","depends_on_id":"Rusticulum-c7u.6","type":"blocks","created_at":"2026-02-08T03:34:00.711753213Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.8","title":"Implement Resource window adaptation","description":"Implement the adaptive window for resource transfers:\n\npub struct WindowState {\n    pub current: usize,       // starts at WINDOW_INITIAL (4)\n    pub min: usize,           // WINDOW_MIN (2)\n    pub max: usize,           // changes with speed class\n    pub flexibility: usize,   // WINDOW_FLEXIBILITY (4)\n}\n\nimpl WindowState {\n    pub fn new() -\u003e Self;\n    pub fn on_success(\u0026mut self);       // current = min(current + 1, max)\n    pub fn on_timeout(\u0026mut self);       // current = max(current - 1, min)\n    pub fn set_speed_class(\u0026mut self, bytes_per_sec: f64);\n}\n\nSpeed class thresholds:\n- \u003c 250 B/s: max = 4\n- \u003c 6250 B/s: max = 10\n- \u003e= 6250 B/s: max = 75\n\nConstants:\n  WINDOW_INITIAL = 4\n  WINDOW_MIN = 2\n  WINDOW_FLEXIBILITY = 4\n\nTest against window_adaptation.json:\n- Window growth sequences under various speed classes\n- Window shrink on timeout\n- Speed class transitions\n\nAdd tracing::debug! for window changes, trace! for individual adaptations.\n\nProperty tests:\n- current is always \u003e= min and \u003c= max\n- on_success never exceeds max\n- on_timeout never goes below min\n- Speed class changes update max correctly\n- If current \u003e new max after speed class change, current is clamped\n\nAcceptance: All window_adaptation.json vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:27.622415703Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:32:27.622415703Z","dependencies":[{"issue_id":"Rusticulum-c7u.8","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:27.622967656Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-c7u.9","title":"Implement Resource advertisement (msgpack)","description":"Implement resource advertisement construction and parsing using msgpack:\n\nResource advertisements use single-character keys for wire compatibility (Part 8 point 8):\n  t = transfer type\n  d = data/content hash\n  n = name/filename\n  h = total hash\n  r = random hash\n  o = original size (uncompressed)\n  i = segment index\n  l = total segments\n  q = request id / hash\n  f = flags\n  m = compressed size\n\npub struct ResourceAdvertisement {\n    pub transfer_type: u8,\n    pub data_hash: Vec\u003cu8\u003e,\n    pub name: Option\u003cString\u003e,\n    pub total_hash: Vec\u003cu8\u003e,\n    pub random_hash: Vec\u003cu8\u003e,\n    pub original_size: u64,\n    pub segment_index: Option\u003cu32\u003e,\n    pub total_segments: Option\u003cu32\u003e,\n    pub request_id: Option\u003cVec\u003cu8\u003e\u003e,\n    pub flags: u8,\n    pub compressed_size: Option\u003cu64\u003e,\n}\n\nimpl ResourceAdvertisement {\n    pub fn to_msgpack(\u0026self) -\u003e Vec\u003cu8\u003e;  // Serialize to msgpack dict with single-char keys\n    pub fn from_msgpack(data: \u0026[u8]) -\u003e Result\u003cSelf, ResourceError\u003e;\n}\n\nUse rmpv crate for precise control over msgpack encoding.\n\nTest against resources.json -\u003e advertisement_vectors:\n- Array of {msgpack_dict (showing field mapping), packed (hex)}\n- Serialize advertisement, verify matches packed hex\n- Deserialize packed hex, verify all fields match\n\nAdd tracing::debug! for advertisement creation/parsing.\n\nProperty tests:\n- Round-trip: from_msgpack(to_msgpack(adv)) preserves all fields\n- Serialized output uses single-character keys\n- Required fields are always present\n\nAcceptance: All resources.json advertisement vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:32:38.561614867Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:32:38.561614867Z","dependencies":[{"issue_id":"Rusticulum-c7u.9","depends_on_id":"Rusticulum-c7u","type":"parent-child","created_at":"2026-02-08T03:32:38.562209182Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn","title":"Interfaces and Node (reticulum-interfaces, reticulum-node)","description":"Implement network interfaces (TCP with HDLC framing, UDP broadcast/unicast, Local IPC via Unix socket, Auto IPv6 multicast discovery) and the node orchestrator (config parsing, interface startup, router wiring, storage). All interfaces are async. The Interface trait defines async transmit/receive, bitrate, and mode. Depends on reticulum-transport.","status":"open","priority":1,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:57.603391869Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:14:57.603391869Z","dependencies":[{"issue_id":"Rusticulum-nrn","depends_on_id":"Rusticulum-uqj","type":"blocks","created_at":"2026-02-08T03:15:08.676336542Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.1","title":"Define Interface trait with async transmit/receive","description":"Define the async Interface trait that all network interfaces implement:\n\n#[async_trait]\npub trait Interface: Send + Sync {\n    fn name(\u0026self) -\u003e \u0026str;\n    fn bitrate(\u0026self) -\u003e u64;  // bits per second\n    fn mtu(\u0026self) -\u003e usize;    // Maximum transmission unit (default 500)\n    fn mode(\u0026self) -\u003e InterfaceMode;\n    fn is_connected(\u0026self) -\u003e bool;\n    \n    async fn transmit(\u0026self, data: \u0026[u8]) -\u003e Result\u003c(), InterfaceError\u003e;\n    async fn receive(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, InterfaceError\u003e;\n    \n    async fn start(\u0026mut self) -\u003e Result\u003c(), InterfaceError\u003e;\n    async fn stop(\u0026mut self) -\u003e Result\u003c(), InterfaceError\u003e;\n}\n\npub enum InterfaceMode {\n    Full,           // Can both send and receive\n    AccessPoint,    // Stationary, higher path TTL\n    Roaming,        // Mobile, shorter path TTL\n    Boundary,       // Gateway between networks\n}\n\npub type InterfaceId = u64;  // Unique interface identifier\n\nAlso define callback/event types:\npub enum InterfaceEvent {\n    PacketReceived { data: Vec\u003cu8\u003e, interface_id: InterfaceId },\n    Connected,\n    Disconnected,\n    Error(InterfaceError),\n}\n\nAdd tracing::info! for interface lifecycle (start/stop/connect/disconnect), debug! for transmit/receive.\n\nAcceptance: Trait compiles, can be implemented by concrete types, async-compatible with tokio.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:39.056091401Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:37:39.056091401Z","dependencies":[{"issue_id":"Rusticulum-nrn.1","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:39.056726137Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.2","title":"Implement TCP interface with HDLC framing","description":"Implement a TCP network interface using HDLC framing from reticulum-core:\n\npub struct TcpInterface {\n    name: String,\n    address: SocketAddr,\n    bitrate: u64,\n    mode: InterfaceMode,\n    stream: Option\u003cTcpStream\u003e,\n}\n\nThe TCP interface:\n- Connects to a remote TCP endpoint (client mode) or listens for connections (server mode)\n- Frames all outgoing packets with HDLC (hdlc_frame from core crate)\n- Unframes all incoming data with HDLC (hdlc_unframe from core crate)\n- Handles connection lifecycle (connect, reconnect on failure)\n- Supports both client and server modes\n\nServer mode: listen on address, accept connections\nClient mode: connect to address, reconnect on disconnect\n\nUse tokio for async I/O:\n- tokio::net::TcpStream for connections\n- tokio::net::TcpListener for server mode\n- Read loop with buffered reader, detecting HDLC frame boundaries\n\nAdd tracing::info! for connection events, debug! for packet send/receive with sizes, error! for connection failures.\n\nEdge cases:\n- Partial HDLC frames (data split across TCP segments)\n- Connection drops mid-frame\n- Multiple frames in single TCP read\n- Empty frames\n- Very large frames (near MTU)\n\nAcceptance: TCP interface can send/receive HDLC-framed packets over TCP, handles connection lifecycle.","status":"open","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:43.057153011Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:37:43.057153011Z","dependencies":[{"issue_id":"Rusticulum-nrn.2","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:43.057827588Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.2","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:16.588243656Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.3","title":"Implement UDP interface","description":"Implement a UDP network interface:\n\npub struct UdpInterface {\n    name: String,\n    bind_address: SocketAddr,\n    target_address: Option\u003cSocketAddr\u003e,  // None for broadcast\n    bitrate: u64,\n    mode: InterfaceMode,\n    socket: Option\u003cUdpSocket\u003e,\n}\n\nThe UDP interface:\n- Binds to a local UDP port\n- Supports unicast (specific target) and broadcast modes\n- Each UDP datagram contains exactly one packet (no framing needed)\n- No connection state to manage\n\nUse tokio::net::UdpSocket for async I/O.\n\nBroadcast mode:\n- Set SO_BROADCAST socket option\n- Send to broadcast address\n- Receive from any source\n\nAdd tracing::info! for interface startup, debug! for packet send/receive.\n\nAcceptance: UDP interface can send/receive raw packets over UDP unicast and broadcast.","status":"open","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:45.157954473Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:37:45.157954473Z","dependencies":[{"issue_id":"Rusticulum-nrn.3","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:45.158503496Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.3","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:17.314344604Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.4","title":"Implement Local interface (Unix IPC)","description":"Implement a Local interface for inter-process communication:\n\npub struct LocalInterface {\n    name: String,\n    socket_path: PathBuf,\n    bitrate: u64,\n    mode: InterfaceMode,\n}\n\nThe Local interface:\n- Uses Unix domain sockets for IPC between Reticulum instances on the same machine\n- Server mode: creates and listens on a Unix socket\n- Client mode: connects to existing Unix socket\n- Uses HDLC framing (same as TCP) for message boundaries\n- Handles socket cleanup on shutdown\n\nUse tokio::net::UnixListener and UnixStream.\n\nAdd tracing::info! for IPC connection events, debug! for message details.\n\nAcceptance: Local interface enables IPC between processes on the same machine.","status":"open","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:47.453282981Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:37:47.453282981Z","dependencies":[{"issue_id":"Rusticulum-nrn.4","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:47.453815743Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.4","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:18.227021311Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.5","title":"Implement Auto interface (IPv6 multicast discovery)","description":"Implement the Auto interface for automatic peer discovery:\n\npub struct AutoInterface {\n    name: String,\n    group_address: Ipv6Addr,  // Multicast group\n    port: u16,\n    discovery_port: u16,\n    bitrate: u64,\n    mode: InterfaceMode,\n    peers: HashMap\u003cSocketAddr, PeerInfo\u003e,\n}\n\nThe Auto interface:\n- Joins an IPv6 multicast group for peer discovery\n- Periodically broadcasts discovery messages\n- Maintains a list of discovered peers\n- Establishes direct TCP/UDP connections to discovered peers\n- Falls back to multicast for initial discovery\n\nDiscovery protocol:\n- Multicast announce with interface identity\n- Peers respond with their connection details\n- Direct connections established after discovery\n\nAdd tracing::info! for peer discovery/loss, debug! for discovery protocol details.\n\nAcceptance: Auto interface discovers peers via IPv6 multicast and establishes connections.","status":"open","priority":2,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:50.109552632Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:37:50.109552632Z","dependencies":[{"issue_id":"Rusticulum-nrn.5","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:50.110180198Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.5","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:18.892095589Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.5","depends_on_id":"Rusticulum-nrn.3","type":"blocks","created_at":"2026-02-08T03:38:19.65116503Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.6","title":"Implement Node orchestrator","description":"Implement the Node struct that ties everything together:\n\npub struct Node {\n    identity: Identity,\n    router: Router,\n    interfaces: Vec\u003cBox\u003cdyn Interface\u003e\u003e,\n    config: NodeConfig,\n    // Internal channels for async coordination\n}\n\npub struct NodeConfig {\n    pub identity_path: Option\u003cPathBuf\u003e,\n    pub interfaces: Vec\u003cInterfaceConfig\u003e,\n    pub enable_transport: bool,\n    pub storage_path: PathBuf,\n}\n\npub enum InterfaceConfig {\n    Tcp { name: String, address: SocketAddr, mode: InterfaceMode },\n    Udp { name: String, bind: SocketAddr, target: Option\u003cSocketAddr\u003e, mode: InterfaceMode },\n    Local { name: String, path: PathBuf },\n    Auto { name: String, group: Ipv6Addr, port: u16 },\n}\n\nimpl Node {\n    pub async fn new(config: NodeConfig) -\u003e Result\u003cSelf, NodeError\u003e;\n    pub async fn start(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e;\n    pub async fn stop(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e;\n    pub fn register_destination(\u0026mut self, destination: Destination);\n    pub fn identity(\u0026self) -\u003e \u0026Identity;\n}\n\nThe Node:\n- Loads or generates identity on startup\n- Creates and starts all configured interfaces\n- Wires interfaces to the router\n- Spawns async tasks for:\n  - Receiving packets from each interface\n  - Processing packets through the router\n  - Sending outgoing packets to appropriate interfaces\n  - Periodic maintenance (path expiration, keepalives, announce propagation)\n- Handles graceful shutdown\n\nConfig parsing: support reading from a TOML or similar config file (matching Python reference format where practical).\n\nAdd tracing::info! for node lifecycle events, debug! for configuration details, error! for startup failures.\n\nAcceptance: Node can start with configured interfaces, route packets between them, and shut down cleanly.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:54.326500682Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:37:54.326500682Z","dependencies":[{"issue_id":"Rusticulum-nrn.6","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:54.327034224Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-nrn.6","depends_on_id":"Rusticulum-nrn.1","type":"blocks","created_at":"2026-02-08T03:38:20.108951603Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-nrn.7","title":"Implement identity persistence and storage","description":"Implement identity and state persistence:\n\npub struct Storage {\n    base_path: PathBuf,\n}\n\nimpl Storage {\n    pub fn new(path: PathBuf) -\u003e Result\u003cSelf, StorageError\u003e;\n    \n    // Identity persistence\n    pub fn load_identity(\u0026self) -\u003e Result\u003cOption\u003cIdentity\u003e, StorageError\u003e;\n    pub fn save_identity(\u0026self, identity: \u0026Identity) -\u003e Result\u003c(), StorageError\u003e;\n    \n    // Known destinations (for path caching across restarts)\n    pub fn load_known_destinations(\u0026self) -\u003e Result\u003cVec\u003c(DestinationHash, IdentityHash)\u003e, StorageError\u003e;\n    pub fn save_known_destination(\u0026self, dest: \u0026DestinationHash, identity: \u0026IdentityHash) -\u003e Result\u003c(), StorageError\u003e;\n    \n    // Path table persistence\n    pub fn load_path_table(\u0026self) -\u003e Result\u003cPathTable, StorageError\u003e;\n    pub fn save_path_table(\u0026self, table: \u0026PathTable) -\u003e Result\u003c(), StorageError\u003e;\n}\n\nFile format should be simple and robust:\n- Identity: raw 64-byte private key file\n- Known destinations: one entry per line, hex-encoded\n- Path table: serialized with serde (JSON or bincode)\n\nAdd tracing::info! for storage operations, warn! for missing/corrupt files.\n\nAcceptance: Identity persists across restarts, known destinations are cached.","status":"open","priority":1,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:37:57.612675634Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:37:57.612675634Z","dependencies":[{"issue_id":"Rusticulum-nrn.7","depends_on_id":"Rusticulum-nrn","type":"parent-child","created_at":"2026-02-08T03:37:57.613227627Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed","title":"Crypto Primitives (reticulum-crypto)","description":"Implement all cryptographic primitives in dependency order: SHA-256/SHA-512, HMAC-SHA256, HKDF-SHA256 (RFC 5869), PKCS7 padding, AES-256-CBC, Token (modified Fernet), X25519 ECDH, Ed25519 signatures. Every primitive must pass against the JSON test vectors. This crate is pure crypto with no protocol concepts, no async, no I/O, and should support optional no_std. Uses RustCrypto family crates (sha2, hmac, aes, cbc, x25519-dalek, ed25519-dalek).","status":"closed","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:42.286647358Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.710294599Z","closed_at":"2026-02-12T19:12:31.710294599Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed","depends_on_id":"Rusticulum-97m","type":"blocks","created_at":"2026-02-08T03:15:08.599369862Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.1","title":"Implement SHA-256 and SHA-512 hash wrappers","description":"Implement thin wrappers around the sha2 crate providing:\n\nfn sha256(data: \u0026[u8]) -\u003e [u8; 32]\nfn sha512(data: \u0026[u8]) -\u003e [u8; 64]\n\nAlso provide incremental/streaming hash support via a wrapper type.\n\nTest against hashes.json which contains:\n- sha256_vectors: array of {input (hex), expected (hex)} - test empty input, block-aligned, multi-block, large inputs\n- sha512_vectors: array of {input (hex), expected (hex)}\n\nAdd tracing::trace! for each hash computation showing input length and output.\n\nProperty tests (proptest):\n- sha256 output is always exactly 32 bytes\n- sha512 output is always exactly 64 bytes\n- Same input always produces same output (deterministic)\n- Different inputs produce different outputs (collision resistance spot check)\n\nAcceptance: All test vectors pass, proptest passes, tracing output visible at trace level.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:17:56.338879063Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.551207687Z","closed_at":"2026-02-12T19:12:31.551207687Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.1","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:17:56.339459136Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.2","title":"Implement HMAC-SHA256","description":"Implement HMAC-SHA256 using the hmac crate:\n\nfn hmac_sha256(key: \u0026[u8], message: \u0026[u8]) -\u003e [u8; 32]\nfn hmac_sha256_verify(key: \u0026[u8], message: \u0026[u8], expected: \u0026[u8; 32]) -\u003e bool\n\nTest against token.json -\u003e hmac_sha256 array, which contains:\n- Array of {key (hex), message (hex), digest (hex)}\n- Verify computed HMAC matches expected digest for each vector\n\nAdd tracing::trace! showing key length and message length.\n\nProperty tests:\n- Output is always 32 bytes\n- Deterministic (same key+message = same HMAC)\n- Different keys produce different HMACs for same message\n- Verify function returns true for correct HMAC, false for corrupted HMAC\n\nEdge cases: empty message, empty key, very long key (longer than block size), single-byte inputs.\n\nAcceptance: All token.json hmac vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:17:59.117527375Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.583381212Z","closed_at":"2026-02-12T19:12:31.583381212Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.2","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:17:59.118072158Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.2","depends_on_id":"Rusticulum-sed.1","type":"blocks","created_at":"2026-02-08T03:23:28.442157088Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.3","title":"Implement HKDF-SHA256 (RFC 5869)","description":"Implement HKDF-SHA256 per RFC 5869 with Reticulum-specific behavior:\n\nfn hkdf(length: usize, ikm: \u0026[u8], salt: \u0026[u8], info: \u0026[u8]) -\u003e Vec\u003cu8\u003e\n\nAlso expose the intermediate PRK for test vector validation:\nfn hkdf_extract(salt: \u0026[u8], ikm: \u0026[u8]) -\u003e [u8; 32]  // returns PRK\nfn hkdf_expand(prk: \u0026[u8; 32], info: \u0026[u8], length: usize) -\u003e Vec\u003cu8\u003e\n\nCRITICAL protocol subtleties:\n- When salt is empty or None, use 32 zero bytes (NOT the HMAC default behavior - be explicit)\n- The expand phase counter is (i+1) % 256 where i is 0-indexed\n- These are documented in implementation plan Part 8 points 1 and 2\n\nTest against hkdf.json which contains:\n- rfc5869_vectors: array of {ikm, salt, info, length, prk, okm} - standard RFC 5869 test cases\n- reticulum_vector: {shared_key, salt, info, length, prk, derived_key} - Reticulum ECDH key derivation case\n- Verify both PRK (intermediate) and OKM/derived_key (final output)\n\nAdd tracing::debug! for key derivation operations showing IKM length, salt length, output length.\n\nProperty tests:\n- Output length matches requested length\n- Deterministic\n- Different IKM produces different output\n- Empty salt produces same result as 32-zero-byte salt\n\nAcceptance: All RFC 5869 vectors pass, Reticulum vector passes, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:03.10267216Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.601319609Z","closed_at":"2026-02-12T19:12:31.601319609Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.3","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:03.103217453Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.3","depends_on_id":"Rusticulum-sed.2","type":"blocks","created_at":"2026-02-08T03:23:29.302569392Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.4","title":"Implement PKCS7 padding","description":"Implement PKCS7 padding and unpadding for 16-byte block size:\n\nfn pkcs7_pad(data: \u0026[u8], block_size: usize) -\u003e Vec\u003cu8\u003e\nfn pkcs7_unpad(data: \u0026[u8], block_size: usize) -\u003e Result\u003c\u0026[u8], CryptoError\u003e\n\nThe block size for Reticulum is always 16 (AES block size).\n\nPadding rules:\n- If data length is multiple of block_size, add full block of padding bytes (each byte = block_size)\n- Otherwise pad to next multiple, each pad byte = number of pad bytes added\n- Unpad: read last byte as pad length, verify all pad bytes match, strip\n\nTest against token.json -\u003e pkcs7_padding array:\n- Array of {input (hex), block_size (int), padded (hex)}\n- Test pad: verify padded output matches\n- Test unpad: verify unpadded output matches original input\n\nAdd tracing::trace! for pad/unpad operations.\n\nProperty tests:\n- Padded output length is always multiple of block_size\n- Padded output is always longer than input (at least 1 byte, at most block_size bytes added)\n- Round-trip: unpad(pad(data)) == data for any input\n- Unpad rejects data with invalid padding bytes\n- Unpad rejects empty input\n- Unpad rejects data where last byte is 0 or \u003e block_size\n\nEdge cases: empty input, input exactly block_size, input one byte less than block_size, very large input.\n\nAcceptance: All token.json pkcs7 vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:06.897111606Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.619500256Z","closed_at":"2026-02-12T19:12:31.619500256Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.4","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:06.897781823Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.5","title":"Implement AES-256-CBC encryption/decryption","description":"Implement AES-256-CBC using the aes and cbc crates:\n\nfn aes256_cbc_encrypt(key: \u0026[u8; 32], iv: \u0026[u8; 16], plaintext: \u0026[u8]) -\u003e Vec\u003cu8\u003e\nfn aes256_cbc_decrypt(key: \u0026[u8; 32], iv: \u0026[u8; 16], ciphertext: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e\n\nEncrypt applies PKCS7 padding before encryption. Decrypt removes PKCS7 padding after decryption.\n\nThis is tested indirectly through the Token module (step 6), but should have its own unit tests:\n- Known key + IV + plaintext -\u003e expected ciphertext\n- Round-trip: decrypt(encrypt(data)) == data\n- Decrypt rejects truncated ciphertext\n- Decrypt rejects ciphertext not aligned to block size\n\nAdd tracing::trace! for encrypt/decrypt showing data lengths.\n\nProperty tests:\n- Ciphertext length is always multiple of 16\n- Ciphertext length \u003e= plaintext length + 1 (at least 1 byte padding)\n- Round-trip: decrypt(encrypt(data)) == data for any input\n- Different IVs produce different ciphertext for same key+plaintext\n- Different keys produce different ciphertext for same IV+plaintext\n\nAcceptance: Unit tests pass, proptests pass, ready for Token integration.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:10.92738418Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.637694354Z","closed_at":"2026-02-12T19:12:31.637694354Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.5","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:10.927948883Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.5","depends_on_id":"Rusticulum-sed.4","type":"blocks","created_at":"2026-02-08T03:23:30.048912512Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.6","title":"Implement Token (modified Fernet) encryption","description":"Implement the Token module - Reticulum's modified Fernet symmetric encryption:\n\nstruct Token { signing_key: [u8; 32], encryption_key: [u8; 32] }\n\nimpl Token {\n    fn new(key: \u0026[u8; 64]) -\u003e Self;  // CRITICAL: signing_key = key[0:32], encryption_key = key[32:64]\n    fn encrypt(\u0026self, plaintext: \u0026[u8]) -\u003e Vec\u003cu8\u003e;\n    fn decrypt(\u0026self, token: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, CryptoError\u003e;\n    // For deterministic test vectors:\n    fn encrypt_with_iv(\u0026self, plaintext: \u0026[u8], iv: \u0026[u8; 16]) -\u003e Vec\u003cu8\u003e;\n}\n\nToken format (differs from standard Fernet - NO version byte, NO timestamp):\n  output = IV(16) || AES-256-CBC(PKCS7(plaintext)) || HMAC-SHA256(signing_key, IV || ciphertext)\n\nCRITICAL key split (implementation plan Part 8 point 10):\n  signing_key = key[0:32]    (FIRST 32 bytes)\n  encryption_key = key[32:64] (LAST 32 bytes)\n  This is the OPPOSITE of what you might expect!\n\nEncrypt:\n1. Generate random 16-byte IV (or use provided IV for testing)\n2. Pad plaintext with PKCS7\n3. Encrypt with AES-256-CBC using encryption_key and IV\n4. Compute HMAC-SHA256(signing_key, IV || ciphertext)\n5. Return IV || ciphertext || HMAC(32 bytes)\n\nDecrypt:\n1. Split: IV = token[0:16], ciphertext = token[16:len-32], hmac = token[len-32:]\n2. Verify HMAC-SHA256(signing_key, IV || ciphertext) == hmac\n3. Decrypt AES-256-CBC with encryption_key and IV\n4. Remove PKCS7 padding\n5. Return plaintext\n\nTOKEN_OVERHEAD = 48 bytes (16 IV + 32 HMAC)\n\nTest against token.json -\u003e encryption_vectors:\n- Array of {key (hex, 64 bytes), plaintext (hex), iv (hex), ciphertext_with_hmac (hex)}\n- Use encrypt_with_iv to get deterministic output, compare with expected\n- Use decrypt on ciphertext_with_hmac, verify plaintext matches\n\nAdd tracing::debug! for encrypt/decrypt operations showing plaintext length.\n\nProperty tests:\n- Token output is always plaintext_len + padding + 48 bytes overhead\n- Round-trip: decrypt(encrypt(data)) == data\n- Decrypt rejects tokens with corrupted HMAC\n- Decrypt rejects tokens with corrupted ciphertext\n- Decrypt rejects tokens shorter than 48 bytes (minimum overhead)\n- Different random IVs produce different tokens\n\nAcceptance: All token.json encryption vectors pass, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:17.951392394Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.655909853Z","closed_at":"2026-02-12T19:12:31.655909853Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.6","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:17.952091013Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.6","depends_on_id":"Rusticulum-sed.2","type":"blocks","created_at":"2026-02-08T03:23:31.190512809Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-sed.6","depends_on_id":"Rusticulum-sed.5","type":"blocks","created_at":"2026-02-08T03:23:31.748496774Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.7","title":"Implement X25519 Diffie-Hellman key exchange","description":"Implement X25519 ECDH using x25519-dalek:\n\nstruct X25519PrivateKey(x25519_dalek::StaticSecret);\nstruct X25519PublicKey(x25519_dalek::PublicKey);  // wraps [u8; 32]\n\nimpl X25519PrivateKey {\n    fn generate() -\u003e Self;\n    fn from_bytes(bytes: \u0026[u8; 32]) -\u003e Self;\n    fn public_key(\u0026self) -\u003e X25519PublicKey;\n    fn diffie_hellman(\u0026self, their_public: \u0026X25519PublicKey) -\u003e [u8; 32];  // shared secret\n}\n\nTest against keypairs.json -\u003e shared_secrets:\n- Array of {keypair_a (index), keypair_b (index), shared_secret (hex)}\n- Load private keys from keypairs array using x25519_private field\n- Compute DH exchange between keypair_a and keypair_b\n- Verify shared_secret matches expected\n\nAlso verify:\n- From keypairs.json keypairs array: load x25519_private, derive public key, verify matches x25519_public\n\nAdd tracing::debug! for key generation and DH exchange.\n\nProperty tests:\n- Public key is always 32 bytes\n- DH is commutative: A.dh(B.pub) == B.dh(A.pub)\n- Different keypairs produce different shared secrets (usually)\n- Generated keys produce valid public keys\n\nAcceptance: All keypairs.json shared_secret vectors pass, public key derivation matches, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:22.123233811Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.674421754Z","closed_at":"2026-02-12T19:12:31.674421754Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.7","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:22.123824046Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-sed.8","title":"Implement Ed25519 digital signatures","description":"Implement Ed25519 signing and verification using ed25519-dalek:\n\nstruct Ed25519PrivateKey(ed25519_dalek::SigningKey);\nstruct Ed25519PublicKey(ed25519_dalek::VerifyingKey);  // wraps [u8; 32]\nstruct Signature([u8; 64]);  // SIGLENGTH = 64\n\nimpl Ed25519PrivateKey {\n    fn generate() -\u003e Self;\n    fn from_bytes(bytes: \u0026[u8; 32]) -\u003e Self;\n    fn public_key(\u0026self) -\u003e Ed25519PublicKey;\n    fn sign(\u0026self, message: \u0026[u8]) -\u003e Signature;\n}\n\nimpl Ed25519PublicKey {\n    fn from_bytes(bytes: \u0026[u8; 32]) -\u003e Result\u003cSelf, CryptoError\u003e;\n    fn verify(\u0026self, message: \u0026[u8], signature: \u0026Signature) -\u003e bool;\n}\n\nTest against keypairs.json -\u003e signature_vectors:\n- Array of {keypair_index (int), message (hex), signature (hex)}\n- Load ed25519_private from keypairs[keypair_index]\n- Sign message, verify signature matches expected 64-byte signature\n- Also verify using public key\n\nAlso verify:\n- From keypairs array: load ed25519_private, derive public key, verify matches ed25519_public\n\nAdd tracing::debug! for sign/verify operations.\n\nProperty tests:\n- Signature is always 64 bytes\n- Sign then verify succeeds for same message\n- Verify fails for wrong message\n- Verify fails for wrong public key\n- Verify fails for corrupted signature\n\nAcceptance: All keypairs.json signature vectors pass, public key derivation matches, proptests pass.","status":"closed","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:18:26.107258267Z","created_by":"Matthew Remmel","updated_at":"2026-02-12T19:12:31.692276708Z","closed_at":"2026-02-12T19:12:31.692276708Z","close_reason":"Closed","dependencies":[{"issue_id":"Rusticulum-sed.8","depends_on_id":"Rusticulum-sed","type":"parent-child","created_at":"2026-02-08T03:18:26.107787249Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj","title":"Transport Layer (reticulum-transport)","description":"Implement routing, announce propagation, path tables, packet deduplication, and interface access codes (IFAC). Includes: router (packet dispatch, destination registry), path_table (entries with TTL: 7 days normal, 1 day AP, 6h roaming), announce propagation (2% bandwidth cap, hop limit 128, dedup), dedup (1M entry hash set, 50% culling), IFAC (hardcoded salt, HMAC suffix). Depends on reticulum-protocol. Uses async (tokio).","status":"open","priority":0,"issue_type":"epic","owner":"matt@remmel.dev","created_at":"2026-02-08T03:14:53.619626622Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:14:53.619626622Z","dependencies":[{"issue_id":"Rusticulum-uqj","depends_on_id":"Rusticulum-c7u","type":"blocks","created_at":"2026-02-08T03:15:08.65728948Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.1","title":"Implement path table with TTL enforcement","description":"Implement the path table for storing discovered routes:\n\npub struct PathEntry {\n    pub destination: DestinationHash,\n    pub next_hop: Option\u003cDestinationHash\u003e,  // None for direct\n    pub interface: InterfaceId,\n    pub hops: u8,\n    pub expires_at: Instant,\n    pub announce_hash: PacketHash,\n    pub created_at: Instant,\n}\n\npub struct PathTable {\n    entries: HashMap\u003cDestinationHash, PathEntry\u003e,\n}\n\nTTL values (time-to-live for path entries):\n- Normal path: 7 days (604800 seconds)\n- Access Point (AP) path: 1 day (86400 seconds)\n- Roaming path: 6 hours (21600 seconds)\n\nimpl PathTable {\n    pub fn new() -\u003e Self;\n    pub fn insert(\u0026mut self, entry: PathEntry);\n    pub fn lookup(\u0026self, destination: \u0026DestinationHash) -\u003e Option\u003c\u0026PathEntry\u003e;\n    pub fn remove(\u0026mut self, destination: \u0026DestinationHash);\n    pub fn expire(\u0026mut self, now: Instant);  // Remove expired entries\n    pub fn len(\u0026self) -\u003e usize;\n    pub fn is_empty(\u0026self) -\u003e bool;\n}\n\nTest against path_requests.json and path_expiration.json:\n- Path entry creation with correct TTLs\n- Lookup returns correct entries\n- Expiration removes entries past TTL\n- Newer announces update existing entries\n\nAdd tracing::debug! for path table operations (insert/lookup/expire), info! for table size changes.\n\nProperty tests:\n- Expired entries are never returned by lookup\n- Insert then lookup returns the entry\n- Entries with different TTL types expire at correct times\n- Table size decreases after expire() when entries are stale\n\nAcceptance: All path test vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:26.121115625Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:35:26.121115625Z","dependencies":[{"issue_id":"Rusticulum-uqj.1","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:26.121731981Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.2","title":"Implement announce propagation with rate limiting","description":"Implement announce propagation rules:\n\npub struct AnnouncePropagation {\n    bandwidth_cap: f64,          // 2% of interface bandwidth\n    hop_limit: u8,               // Maximum 128 hops\n    seen_announces: HashSet\u003cPacketHash\u003e,  // Deduplication\n    rate_tracker: BandwidthTracker,\n}\n\nPropagation rules:\n- Rate limiting: announces must not exceed 2% of interface bandwidth\n- Hop limit: announces with hops \u003e= 128 are dropped\n- Deduplication: announce packet_hash is tracked, duplicates are dropped\n- Hop increment: hops field is incremented before forwarding\n- Retransmit delay: based on hop count and interface bitrate\n\nimpl AnnouncePropagation {\n    pub fn new(bandwidth_bps: u64) -\u003e Self;\n    pub fn should_propagate(\u0026mut self, announce: \u0026RawPacket) -\u003e PropagateDecision;\n    pub fn record_propagation(\u0026mut self, size: usize);\n    pub fn increment_hops(\u0026self, packet: \u0026mut RawPacket);\n}\n\npub enum PropagateDecision {\n    Propagate,\n    Drop(DropReason),\n    Delay(Duration),\n}\n\npub enum DropReason {\n    HopLimitExceeded,\n    Duplicate,\n    RateLimited,\n}\n\nTest against announces.json (propagation rules section if present):\n- Verify hop counting\n- Verify deduplication\n- Verify rate limiting behavior\n\nAdd tracing::info! for propagated announces, warn! for dropped announces, debug! for rate limiting decisions.\n\nProperty tests:\n- Announces with hops \u003e= 128 are always dropped\n- Same announce is never propagated twice\n- Bandwidth usage stays within 2% cap over time\n- Hops always increment by 1\n\nAcceptance: Propagation rules match reference implementation behavior, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:32.200375785Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:35:32.200375785Z","dependencies":[{"issue_id":"Rusticulum-uqj.2","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:32.201079755Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-uqj.2","depends_on_id":"Rusticulum-uqj.1","type":"blocks","created_at":"2026-02-08T03:36:19.880198886Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.3","title":"Implement packet router and destination registry","description":"Implement the central packet router:\n\npub struct Router {\n    destinations: HashMap\u003cDestinationHash, DestinationInfo\u003e,\n    path_table: PathTable,\n    announce_propagation: AnnouncePropagation,\n    interfaces: Vec\u003cInterfaceId\u003e,\n}\n\npub struct DestinationInfo {\n    pub destination_type: DestinationType,\n    pub handler: Box\u003cdyn PacketHandler\u003e,\n    pub proof_strategy: ProofStrategy,\n}\n\npub enum ProofStrategy {\n    ProveNone,\n    ProveApp,\n    ProveAll,\n}\n\nimpl Router {\n    pub fn new() -\u003e Self;\n    pub fn register_destination(\u0026mut self, hash: DestinationHash, info: DestinationInfo);\n    pub fn unregister_destination(\u0026mut self, hash: \u0026DestinationHash);\n    pub fn route_packet(\u0026mut self, packet: \u0026RawPacket, source_interface: InterfaceId) -\u003e Vec\u003cRouterAction\u003e;\n    pub fn lookup_path(\u0026self, destination: \u0026DestinationHash) -\u003e Option\u003c\u0026PathEntry\u003e;\n}\n\npub enum RouterAction {\n    DeliverLocal(DestinationHash, Vec\u003cu8\u003e),\n    Forward(InterfaceId, Vec\u003cu8\u003e),\n    Broadcast(Vec\u003cu8\u003e),\n    Drop(DropReason),\n}\n\nRouting logic:\n1. Check packet dedup (drop if seen)\n2. For announces: validate, update path table, propagate per rules\n3. For data/proof: lookup destination, deliver locally or forward via path table\n4. For link requests: deliver to destination if registered\n5. For HEADER_2 (transport): strip transport header, re-route\n\nTest against multi_hop_routing.json:\n- Multi-hop packet forwarding\n- Transport header insertion/removal\n- Correct interface selection for forwarding\n\nAdd tracing::info! for packet routing decisions, debug! for path lookups, warn! for dropped packets.\n\nProperty tests:\n- Registered destinations receive their packets\n- Unregistered destinations result in forwarding or drop\n- Duplicate packets are never delivered\n- HEADER_2 transport_id is correctly handled\n\nAcceptance: All multi_hop_routing.json vectors pass, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:44.042672506Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:35:44.042672506Z","dependencies":[{"issue_id":"Rusticulum-uqj.3","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:44.043224409Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-uqj.3","depends_on_id":"Rusticulum-uqj.1","type":"blocks","created_at":"2026-02-08T03:36:22.920602986Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-uqj.3","depends_on_id":"Rusticulum-uqj.2","type":"blocks","created_at":"2026-02-08T03:36:26.202606067Z","created_by":"Matthew Remmel"},{"issue_id":"Rusticulum-uqj.3","depends_on_id":"Rusticulum-uqj.4","type":"blocks","created_at":"2026-02-08T03:36:29.76839612Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.4","title":"Implement packet deduplication","description":"Implement the packet hash deduplication system:\n\npub struct PacketDedup {\n    seen: HashSet\u003cPacketHash\u003e,\n    max_entries: usize,  // 1,000,000 (1M)\n}\n\nimpl PacketDedup {\n    pub fn new() -\u003e Self;\n    pub fn is_duplicate(\u0026mut self, hash: \u0026PacketHash) -\u003e bool;\n    pub fn record(\u0026mut self, hash: PacketHash);\n    pub fn len(\u0026self) -\u003e usize;\n    \n    // When entries exceed max, cull 50%\n    fn cull(\u0026mut self);\n}\n\nCulling strategy:\n- Maximum 1,000,000 entries\n- When max is reached, remove 50% of entries (500,000)\n- Culling should remove older entries (FIFO-like behavior)\n- Consider using a VecDeque or similar ordered structure for age-based culling\n\nAdd tracing::info! for culling events (count before/after), debug! for duplicate detection.\n\nProperty tests:\n- After recording, is_duplicate returns true\n- After culling, size is approximately 50% of max\n- Size never exceeds max_entries (or only briefly before cull)\n- Fresh hashes are never marked as duplicates\n\nAcceptance: Dedup handles 1M+ insertions correctly, culling works, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:49.030856482Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:35:49.030856482Z","dependencies":[{"issue_id":"Rusticulum-uqj.4","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:49.031380953Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.5","title":"Implement Interface Access Codes (IFAC)","description":"Implement IFAC for interface authentication:\n\nIFAC uses a hardcoded salt and HMAC to compute a suffix that is appended to packets for interface-level access control.\n\npub struct Ifac {\n    hmac_key: [u8; 32],  // Derived from interface access code + hardcoded salt\n}\n\nimpl Ifac {\n    pub fn new(access_code: \u0026[u8]) -\u003e Self;\n    pub fn compute_suffix(\u0026self, packet_data: \u0026[u8]) -\u003e Vec\u003cu8\u003e;  // HMAC suffix\n    pub fn verify(\u0026self, packet_data: \u0026[u8], suffix: \u0026[u8]) -\u003e bool;\n    pub fn sign_packet(\u0026self, packet: \u0026[u8]) -\u003e Vec\u003cu8\u003e;  // packet + suffix\n    pub fn verify_and_strip(\u0026self, signed_packet: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, IfacError\u003e;\n}\n\nThe IFAC key is derived from the access code string using a hardcoded salt value defined in the reference implementation.\n\nAdd tracing::debug! for IFAC operations, warn! for verification failures.\n\nProperty tests:\n- verify(data, compute_suffix(data)) always returns true\n- Different access codes produce different suffixes\n- Corrupted suffix fails verification\n- Round-trip: verify_and_strip(sign_packet(data)) == data\n\nAcceptance: IFAC computation matches reference implementation, proptests pass.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:35:57.05106736Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:35:57.05106736Z","dependencies":[{"issue_id":"Rusticulum-uqj.5","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:35:57.051737147Z","created_by":"Matthew Remmel"}]}
{"id":"Rusticulum-uqj.6","title":"Implement transport error types","description":"Define error types for the transport crate:\n\n#[derive(Debug, thiserror::Error)]\npub enum RouterError {\n    #[error(\"no path to destination {0}\")]\n    NoPath(DestinationHash),\n    #[error(\"destination not registered: {0}\")]\n    NotRegistered(DestinationHash),\n    #[error(\"packet too large: {size} \u003e {max}\")]\n    PacketTooLarge { size: usize, max: usize },\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum PathError { ... }\n\n#[derive(Debug, thiserror::Error)]\npub enum IfacError { ... }\n\nAcceptance: All error types compile, provide useful messages.","status":"open","priority":0,"issue_type":"task","owner":"matt@remmel.dev","created_at":"2026-02-08T03:36:02.997230021Z","created_by":"Matthew Remmel","updated_at":"2026-02-08T03:36:02.997230021Z","dependencies":[{"issue_id":"Rusticulum-uqj.6","depends_on_id":"Rusticulum-uqj","type":"parent-child","created_at":"2026-02-08T03:36:02.9979342Z","created_by":"Matthew Remmel"}]}
